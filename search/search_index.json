{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ewrap Documentation","text":"<p>Welcome to the documentation for <code>ewrap</code>, a sophisticated error handling package for Go applications that provides comprehensive error management capabilities with a focus on performance and developer experience.</p>"},{"location":"#overview","title":"Overview","text":"<p>ewrap is designed to make error handling in Go applications more robust, informative, and maintainable. It provides a rich set of features while maintaining excellent performance characteristics through careful optimization and efficient memory management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stack Traces: Automatically capture and filter stack traces for meaningful error debugging</li> <li>Error Wrapping: Maintain error chains while preserving context</li> <li>Metadata Attachment: Attach and manage arbitrary key-value pairs to errors</li> <li>Logging Integration: Flexible logger interface supporting major logging frameworks</li> <li>Error Categorization: Built-in error types and severity levels</li> <li>Circuit Breaker Pattern: Protect your systems from cascading failures</li> <li>Efficient Error Grouping: Pool-based error group management</li> <li>Context Preservation: Rich error context preservation</li> <li>Thread-Safe Operations: Safe for concurrent use</li> <li>Format Options: JSON and YAML output support</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a quick example of how ewrap can be used in your application:</p> <pre><code>func processOrder(ctx context.Context, orderID string) error {\n    // Get an error group from the pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Create a circuit breaker\n    cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\n    // Add validation errors to the group\n    if err := validateOrder(orderID); err != nil {\n        eg.Add(ewrap.Wrap(err, \"invalid order\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation),\n            ewrap.WithLogger(logger)))\n    }\n\n    // Handle database operations with circuit breaker\n    if !eg.HasErrors() &amp;&amp; cb.CanExecute() {\n        if err := saveToDatabase(orderID); err != nil {\n            cb.RecordFailure()\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n                ewrap.WithRetry(3, time.Second*5))\n        }\n        cb.RecordSuccess()\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To start using ewrap in your project, visit the Installation guide, followed by the Quick Start tutorial.</p>"},{"location":"#why-ewrap","title":"Why ewrap?","text":"<p>ewrap was created to address common challenges in error handling:</p> <ol> <li>Lack of Context: Traditional error handling often loses important context</li> <li>Performance Overhead: Many error handling libraries introduce significant overhead</li> <li>Memory Management: Poor memory management in error handling can lead to increased GC pressure</li> <li>Inconsistent Logging: Different parts of an application often handle error logging differently</li> <li>Missing Stack Traces: Getting meaningful stack traces can be challenging</li> <li>Circuit Breaking: Protecting systems from cascading failures requires complex implementation</li> </ol> <p>ewrap solves these challenges while maintaining excellent performance characteristics and providing a clean, intuitive API.</p>"},{"location":"advanced/error-strategies/","title":"Error Handling Strategies","text":"<p>Understanding how to effectively handle errors is crucial for building robust applications. This guide explores various error handling strategies using ewrap and explains when to use each approach.</p>"},{"location":"advanced/error-strategies/#understanding-error-context","title":"Understanding Error Context","text":"<p>Error context is more than just an error message - it's the complete picture of what happened when an error occurred. With ewrap, you can capture rich context that helps with debugging and error resolution.</p>"},{"location":"advanced/error-strategies/#basic-context","title":"Basic Context","text":"<p>At its simplest, context includes:</p> <pre><code>err := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError))\n</code></pre> <p>This tells us:</p> <ul> <li>What happened (\"user not found\")</li> <li>The type of error (NotFound)</li> <li>How severe the error is (Error level)</li> </ul>"},{"location":"advanced/error-strategies/#enhanced-context","title":"Enhanced Context","text":"<p>For more complex scenarios, you can add detailed context:</p> <pre><code>err := ewrap.New(\"database query failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger)).\n    WithMetadata(\"query\", query).\n    WithMetadata(\"table\", \"users\").\n    WithMetadata(\"affected_rows\", 0).\n    WithMetadata(\"latency_ms\", queryTime.Milliseconds())\n</code></pre> <p>This provides a complete picture:</p> <ul> <li>The operation that failed</li> <li>Where it failed</li> <li>Related technical details</li> <li>Performance metrics</li> </ul>"},{"location":"advanced/error-strategies/#error-group-strategies","title":"Error Group Strategies","text":"<p>Error groups are powerful tools for handling multiple potential errors in a single operation. Here's how to use them effectively:</p>"},{"location":"advanced/error-strategies/#validation-scenarios","title":"Validation Scenarios","text":"<p>When validating multiple fields or conditions:</p> <pre><code>func validateUser(user User) error {\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate email\n    if !isValidEmail(user.Email) {\n        eg.Add(ewrap.New(\"invalid email format\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate age\n    if user.Age &lt; 18 {\n        eg.Add(ewrap.New(\"user must be 18 or older\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate username\n    if len(user.Username) &lt; 3 {\n        eg.Add(ewrap.New(\"username too short\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#parallel-operations","title":"Parallel Operations","text":"<p>When handling concurrent operations:</p> <pre><code>func processItems(ctx context.Context, items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            if err := processItem(ctx, item); err != nil {\n                eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#circuit-breaker-patterns","title":"Circuit Breaker Patterns","text":"<p>Circuit breakers help prevent system overload by failing fast when problems are detected. Here are some patterns for using them effectively:</p>"},{"location":"advanced/error-strategies/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<p>For simple protection:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 5, time.Minute)\n\nfunc queryDatabase() error {\n    if !cb.CanExecute() {\n        return ewrap.New(\"circuit breaker open\",\n            ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n            ewrap.WithMetadata(\"breaker\", \"database\"))\n    }\n\n    if err := performQuery(); err != nil {\n        cb.RecordFailure()\n        return err\n    }\n\n    cb.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"advanced/error-strategies/#cascading-circuit-breakers","title":"Cascading Circuit Breakers","text":"<p>For systems with dependencies:</p> <pre><code>type Service struct {\n    dbBreaker    *ewrap.CircuitBreaker\n    cacheBreaker *ewrap.CircuitBreaker\n    apiBreaker   *ewrap.CircuitBreaker\n}\n\nfunc (s *Service) getData(ctx context.Context, id string) (Data, error) {\n    // Try cache first\n    if s.cacheBreaker.CanExecute() {\n        data, err := queryCache(id)\n        if err == nil {\n            s.cacheBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.cacheBreaker.RecordFailure()\n    }\n\n    // Fall back to database\n    if s.dbBreaker.CanExecute() {\n        data, err := queryDatabase(id)\n        if err == nil {\n            s.dbBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.dbBreaker.RecordFailure()\n    }\n\n    // Last resort: external API\n    if s.apiBreaker.CanExecute() {\n        data, err := queryAPI(id)\n        if err == nil {\n            s.apiBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.apiBreaker.RecordFailure()\n    }\n\n    return Data{}, ewrap.New(\"all data sources failed\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"advanced/error-strategies/#best-practices-for-error-recovery","title":"Best Practices for Error Recovery","text":"<p>When handling errors, consider implementing recovery strategies:</p> <ol> <li> <p>Graceful Degradation:</p> <pre><code>func getProductDetails(ctx context.Context, id string) (Product, error) {\n    var product Product\n\n    // Get core product data\n    data, err := getProductData(id)\n    if err != nil {\n        // Log the error but continue with partial data\n        logger.Error(\"failed to get full product data\", \"error\", err)\n        product.Status = \"partial\"\n    } else {\n        product.Status = \"complete\"\n    }\n\n    // Get non-critical enrichment data\n    reviews, err := getProductReviews(id)\n    if err != nil {\n        // Add metadata about missing data\n        err = ewrap.Wrap(err, \"failed to get reviews\",\n            ewrap.WithMetadata(\"missing_component\", \"reviews\"),\n            ewrap.WithErrorType(ewrap.ErrorTypePartial))\n        logger.Warn(\"serving product without reviews\", \"error\", err)\n    }\n\n    return product, nil\n}\n</code></pre> </li> <li> <p>Retry Patterns:</p> </li> </ol> <pre><code>func withRetry(operation func() error, maxAttempts int, delay time.Duration) error {\n    var lastErr error\n\n    for attempt := 1; attempt &lt;= maxAttempts; attempt++ {\n        err := operation()\n        if err == nil {\n            return nil\n        }\n\n        lastErr = ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithMetadata(\"attempt\", attempt),\n            ewrap.WithMetadata(\"max_attempts\", maxAttempts))\n\n        if attempt &lt; maxAttempts {\n            time.Sleep(delay * time.Duration(attempt))\n        }\n    }\n\n    return lastErr\n}\n</code></pre> <p>The key to effective error handling is choosing the right strategy for each situation. Consider:</p> <ul> <li>The criticality of the operation</li> <li>Performance requirements</li> <li>User experience implications</li> <li>System resources</li> <li>Dependencies and their reliability</li> </ul> <p>By understanding these factors and using ewrap's features appropriately, you can build robust and maintainable error handling systems.</p>"},{"location":"features/error-creation/","title":"Error Creation","text":"<p>Understanding how to create errors effectively is fundamental to using the ewrap package. This guide explains the different ways to create errors and when to use each approach.</p>"},{"location":"features/error-creation/#basic-error-creation","title":"Basic Error Creation","text":"<p>The most straightforward way to create an error is using the <code>New</code> function. However, there's more to consider than just the error message.</p> <pre><code>// Simple error creation\nerr := ewrap.New(\"user not found\")\n\n// With additional context\nerr := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError),\n    ewrap.WithLogger(logger))\n</code></pre> <p>The <code>New</code> function captures a stack trace automatically, allowing you to trace the error's origin later. This is particularly valuable when debugging complex applications where errors might surface far from their source.</p>"},{"location":"features/error-creation/#creating-errors-with-options","title":"Creating Errors with Options","text":"<p>The <code>New</code> function accepts variadic options that configure the error's behavior and context:</p> <pre><code>err := ewrap.New(\"failed to process payment\",\n    // Add request context\n    ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical),\n    // Configure logging\n    ewrap.WithLogger(logger),\n    // Add retry information\n    ewrap.WithRetry(3, time.Second*5))\n</code></pre> <p>Each option serves a specific purpose:</p> <ul> <li><code>WithContext</code>: Adds request context and error classification</li> <li><code>WithLogger</code>: Configures error logging behavior</li> <li><code>WithRetry</code>: Specifies retry behavior for recoverable errors</li> </ul>"},{"location":"features/error-creation/#creating-domain-specific-errors","title":"Creating Domain-Specific Errors","text":"<p>For domain-specific error cases, you can combine error creation with metadata:</p> <pre><code>func validateUserAge(age int) error {\n    if age &lt; 18 {\n        return ewrap.New(\"user is underage\",\n            ewrap.WithContext(context.Background(), ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"minimum_age\", 18).\n            WithMetadata(\"provided_age\", age)\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-creation/#best-practices-for-error-creation","title":"Best Practices for Error Creation","text":"<p>When creating errors, follow these guidelines for maximum effectiveness:</p> <ol> <li> <p>Be Specific: Error messages should clearly indicate what went wrong:</p> <pre><code>// Good\nerr := ewrap.New(\"database connection timeout after 5 seconds\")\n\n// Not as helpful\nerr := ewrap.New(\"database error\")\n</code></pre> </li> <li> <p>Include Relevant Context: Add context that helps with debugging:</p> <pre><code>err := ewrap.New(\"failed to update user profile\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError)).\n    WithMetadata(\"user_id\", userID).\n    WithMetadata(\"fields_updated\", fields)\n</code></pre> </li> <li> <p>Use Appropriate Error Types: Choose error types that match the situation:</p> <pre><code>// For validation errors\nerr := ewrap.New(\"invalid email format\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityWarning))\n\n// For system errors\nerr := ewrap.New(\"failed to connect to database\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n</code></pre> </li> <li> <p>Consider Recovery Options: Include information that helps with recovery:</p> <pre><code>err := ewrap.New(\"rate limit exceeded\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityWarning)).\n    WithMetadata(\"retry_after\", time.Now().Add(time.Minute)).\n    WithMetadata(\"current_rate\", currentRate).\n    WithMetadata(\"limit\", rateLimit)\n</code></pre> </li> </ol>"},{"location":"features/error-creation/#working-with-stack-traces","title":"Working with Stack Traces","text":"<p>Every error created with <code>New</code> automatically captures a stack trace:</p> <pre><code>func processOrder(orderID string) error {\n    err := ewrap.New(\"order processing failed\")\n    fmt.Println(err.Stack()) // Prints the stack trace\n    return err\n}\n</code></pre> <p>The stack trace includes function names, file names, and line numbers, making it easier to trace the error's origin.</p>"},{"location":"features/error-creation/#error-creation-in-tests","title":"Error Creation in Tests","text":"<p>When writing tests, you might want to create errors for specific scenarios:</p> <pre><code>func TestOrderProcessing(t *testing.T) {\n    // Create a test error\n    testErr := ewrap.New(\"simulated database error\",\n        ewrap.WithContext(context.Background(), ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n\n    // Mock database returns our test error\n    mockDB := &amp;MockDatabase{\n        QueryFunc: func() error {\n            return testErr\n        },\n    }\n\n    err := processOrder(mockDB, \"order123\")\n\n    // Verify error handling\n    if !errors.Is(err, testErr) {\n        t.Errorf(\"expected error %v, got %v\", testErr, err)\n    }\n}\n</code></pre>"},{"location":"features/error-creation/#thread-safety","title":"Thread Safety","text":"<p>All error creation operations in ewrap are thread-safe. You can safely create errors from multiple goroutines:</p> <pre><code>func processItems(items []string) []error {\n    var wg sync.WaitGroup\n    errors := make([]error, 0)\n    var mu sync.Mutex\n\n    for _, item := range items {\n        wg.Add(1)\n        go func(item string) {\n            defer wg.Done()\n            if err := process(item); err != nil {\n                mu.Lock()\n                errors = append(errors, ewrap.New(\"processing failed\",\n                    ewrap.WithMetadata(\"item\", item)))\n                mu.Unlock()\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return errors\n}\n</code></pre>"},{"location":"features/error-creation/#performance-considerations","title":"Performance Considerations","text":"<p>Error creation in ewrap is optimized for both CPU and memory usage. However, consider these performance tips:</p> <ol> <li>Reuse error types for common errors instead of creating new ones</li> <li>Only capture stack traces when necessary</li> <li>Be mindful of metadata quantity in high-throughput scenarios</li> <li>Use error pools for frequent error creation scenarios</li> </ol> <p>Remember: error creation should be reserved for exceptional cases. Don't use errors for normal control flow in your application.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with ewrap quickly. We'll cover the basic concepts and show you how to use the main features of the package.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#creating-errors","title":"Creating Errors","text":"<p>The simplest way to create an error with ewrap is using the <code>New</code> function:</p> <pre><code>err := ewrap.New(\"something went wrong\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-context","title":"Adding Context","text":"<p>You can add context to your errors using various options:</p> <pre><code>err := ewrap.New(\"database connection failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger))\n</code></pre>"},{"location":"getting-started/quickstart/#wrapping-errors","title":"Wrapping Errors","text":"<p>When you want to add context to an existing error:</p> <pre><code>if err != nil {\n    return ewrap.Wrap(err, \"failed to process request\")\n}\n</code></pre>"},{"location":"getting-started/quickstart/#using-error-groups","title":"Using Error Groups","text":"<p>Error groups help you collect and manage multiple errors:</p> <pre><code>// Create an error group pool\npool := ewrap.NewErrorGroupPool(4)\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Don't forget to release it back to the pool\n\n// Add errors as needed\neg.Add(err1)\neg.Add(err2)\n\nif eg.HasErrors() {\n    return eg.Error()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#implementing-circuit-breaker","title":"Implementing Circuit Breaker","text":"<p>Protect your system from cascading failures:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\nif cb.CanExecute() {\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()\n        return err\n    }\n    cb.RecordSuccess()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ol> <li>Learn about Error Types</li> <li>Explore Logging Integration</li> <li>Study Advanced Usage</li> <li>Check out complete Examples</li> </ol>"},{"location":"getting-started/quickstart/#best-practices","title":"Best Practices","text":"<p>Here are some best practices to follow when using ewrap:</p> <ol> <li>Always provide meaningful error messages</li> <li>Use appropriate error types and severity levels</li> <li>Release error groups back to their pools</li> <li>Configure circuit breakers based on your system's characteristics</li> <li>Implement proper logging integration</li> <li>Use metadata to add relevant debugging information</li> </ol>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you might find useful:</p> <pre><code>func processItem(ctx context.Context, item string) error {\n    // Create error group from pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate input\n    if err := validate(item); err != nil {\n        eg.Add(ewrap.Wrap(err, \"validation failed\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Process if no validation errors\n    if !eg.HasErrors() {\n        if err := process(item); err != nil {\n            return ewrap.Wrap(err, \"processing failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeInternal))\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre> <p>This is just a starting point. For more detailed information about specific features, check out the relevant sections in the documentation.</p>"}]}