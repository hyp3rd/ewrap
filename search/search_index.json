{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ewrap Documentation","text":"<p>Welcome to the documentation for <code>ewrap</code>, a sophisticated error handling package for Go applications that provides comprehensive error management capabilities with a focus on performance and developer experience.</p>"},{"location":"#overview","title":"Overview","text":"<p>ewrap is designed to make error handling in Go applications more robust, informative, and maintainable. It provides a rich set of features while maintaining excellent performance characteristics through careful optimization and efficient memory management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stack Traces: Automatically capture and filter stack traces for meaningful error debugging</li> <li>Error Wrapping: Maintain error chains while preserving context</li> <li>Metadata Attachment: Attach and manage arbitrary key-value pairs to errors</li> <li>Logging Integration: Flexible logger interface supporting major logging frameworks</li> <li>Error Categorization: Built-in error types and severity levels</li> <li>Circuit Breaker Pattern: Protect your systems from cascading failures</li> <li>Efficient Error Grouping: Pool-based error group management</li> <li>Context Preservation: Rich error context preservation</li> <li>Thread-Safe Operations: Safe for concurrent use</li> <li>Format Options: JSON and YAML output support</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a quick example of how ewrap can be used in your application:</p> <pre><code>func processOrder(ctx context.Context, orderID string) error {\n    // Get an error group from the pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Create a circuit breaker\n    cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\n    // Add validation errors to the group\n    if err := validateOrder(orderID); err != nil {\n        eg.Add(ewrap.Wrap(err, \"invalid order\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation),\n            ewrap.WithLogger(logger)))\n    }\n\n    // Handle database operations with circuit breaker\n    if !eg.HasErrors() &amp;&amp; cb.CanExecute() {\n        if err := saveToDatabase(orderID); err != nil {\n            cb.RecordFailure()\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n                ewrap.WithRetry(3, time.Second*5))\n        }\n        cb.RecordSuccess()\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To start using ewrap in your project, visit the Installation guide, followed by the Quick Start tutorial.</p>"},{"location":"#why-ewrap","title":"Why ewrap?","text":"<p>ewrap was created to address common challenges in error handling:</p> <ol> <li>Lack of Context: Traditional error handling often loses important context</li> <li>Performance Overhead: Many error handling libraries introduce significant overhead</li> <li>Memory Management: Poor memory management in error handling can lead to increased GC pressure</li> <li>Inconsistent Logging: Different parts of an application often handle error logging differently</li> <li>Missing Stack Traces: Getting meaningful stack traces can be challenging</li> <li>Circuit Breaking: Protecting systems from cascading failures requires complex implementation</li> </ol> <p>ewrap solves these challenges while maintaining excellent performance characteristics and providing a clean, intuitive API.</p>"},{"location":"advanced/error-strategies/","title":"Error Handling Strategies","text":"<p>Understanding how to effectively handle errors is crucial for building robust applications. This guide explores various error handling strategies using ewrap and explains when to use each approach.</p>"},{"location":"advanced/error-strategies/#understanding-error-context","title":"Understanding Error Context","text":"<p>Error context is more than just an error message - it's the complete picture of what happened when an error occurred. With ewrap, you can capture rich context that helps with debugging and error resolution.</p>"},{"location":"advanced/error-strategies/#basic-context","title":"Basic Context","text":"<p>At its simplest, context includes:</p> <pre><code>err := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError))\n</code></pre> <p>This tells us:</p> <ul> <li>What happened (\"user not found\")</li> <li>The type of error (NotFound)</li> <li>How severe the error is (Error level)</li> </ul>"},{"location":"advanced/error-strategies/#enhanced-context","title":"Enhanced Context","text":"<p>For more complex scenarios, you can add detailed context:</p> <pre><code>err := ewrap.New(\"database query failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger)).\n    WithMetadata(\"query\", query).\n    WithMetadata(\"table\", \"users\").\n    WithMetadata(\"affected_rows\", 0).\n    WithMetadata(\"latency_ms\", queryTime.Milliseconds())\n</code></pre> <p>This provides a complete picture:</p> <ul> <li>The operation that failed</li> <li>Where it failed</li> <li>Related technical details</li> <li>Performance metrics</li> </ul>"},{"location":"advanced/error-strategies/#error-group-strategies","title":"Error Group Strategies","text":"<p>Error groups are powerful tools for handling multiple potential errors in a single operation. Here's how to use them effectively:</p>"},{"location":"advanced/error-strategies/#validation-scenarios","title":"Validation Scenarios","text":"<p>When validating multiple fields or conditions:</p> <pre><code>func validateUser(user User) error {\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate email\n    if !isValidEmail(user.Email) {\n        eg.Add(ewrap.New(\"invalid email format\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate age\n    if user.Age &lt; 18 {\n        eg.Add(ewrap.New(\"user must be 18 or older\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate username\n    if len(user.Username) &lt; 3 {\n        eg.Add(ewrap.New(\"username too short\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#parallel-operations","title":"Parallel Operations","text":"<p>When handling concurrent operations:</p> <pre><code>func processItems(ctx context.Context, items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            if err := processItem(ctx, item); err != nil {\n                eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#circuit-breaker-patterns","title":"Circuit Breaker Patterns","text":"<p>Circuit breakers help prevent system overload by failing fast when problems are detected. Here are some patterns for using them effectively:</p>"},{"location":"advanced/error-strategies/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<p>For simple protection:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 5, time.Minute)\n\nfunc queryDatabase() error {\n    if !cb.CanExecute() {\n        return ewrap.New(\"circuit breaker open\",\n            ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n            ewrap.WithMetadata(\"breaker\", \"database\"))\n    }\n\n    if err := performQuery(); err != nil {\n        cb.RecordFailure()\n        return err\n    }\n\n    cb.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"advanced/error-strategies/#cascading-circuit-breakers","title":"Cascading Circuit Breakers","text":"<p>For systems with dependencies:</p> <pre><code>type Service struct {\n    dbBreaker    *ewrap.CircuitBreaker\n    cacheBreaker *ewrap.CircuitBreaker\n    apiBreaker   *ewrap.CircuitBreaker\n}\n\nfunc (s *Service) getData(ctx context.Context, id string) (Data, error) {\n    // Try cache first\n    if s.cacheBreaker.CanExecute() {\n        data, err := queryCache(id)\n        if err == nil {\n            s.cacheBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.cacheBreaker.RecordFailure()\n    }\n\n    // Fall back to database\n    if s.dbBreaker.CanExecute() {\n        data, err := queryDatabase(id)\n        if err == nil {\n            s.dbBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.dbBreaker.RecordFailure()\n    }\n\n    // Last resort: external API\n    if s.apiBreaker.CanExecute() {\n        data, err := queryAPI(id)\n        if err == nil {\n            s.apiBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.apiBreaker.RecordFailure()\n    }\n\n    return Data{}, ewrap.New(\"all data sources failed\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"advanced/error-strategies/#best-practices-for-error-recovery","title":"Best Practices for Error Recovery","text":"<p>When handling errors, consider implementing recovery strategies:</p> <ol> <li> <p>Graceful Degradation:</p> <pre><code>func getProductDetails(ctx context.Context, id string) (Product, error) {\n    var product Product\n\n    // Get core product data\n    data, err := getProductData(id)\n    if err != nil {\n        // Log the error but continue with partial data\n        logger.Error(\"failed to get full product data\", \"error\", err)\n        product.Status = \"partial\"\n    } else {\n        product.Status = \"complete\"\n    }\n\n    // Get non-critical enrichment data\n    reviews, err := getProductReviews(id)\n    if err != nil {\n        // Add metadata about missing data\n        err = ewrap.Wrap(err, \"failed to get reviews\",\n            ewrap.WithMetadata(\"missing_component\", \"reviews\"),\n            ewrap.WithErrorType(ewrap.ErrorTypePartial))\n        logger.Warn(\"serving product without reviews\", \"error\", err)\n    }\n\n    return product, nil\n}\n</code></pre> </li> <li> <p>Retry Patterns:</p> </li> </ol> <pre><code>func withRetry(operation func() error, maxAttempts int, delay time.Duration) error {\n    var lastErr error\n\n    for attempt := 1; attempt &lt;= maxAttempts; attempt++ {\n        err := operation()\n        if err == nil {\n            return nil\n        }\n\n        lastErr = ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithMetadata(\"attempt\", attempt),\n            ewrap.WithMetadata(\"max_attempts\", maxAttempts))\n\n        if attempt &lt; maxAttempts {\n            time.Sleep(delay * time.Duration(attempt))\n        }\n    }\n\n    return lastErr\n}\n</code></pre> <p>The key to effective error handling is choosing the right strategy for each situation. Consider:</p> <ul> <li>The criticality of the operation</li> <li>Performance requirements</li> <li>User experience implications</li> <li>System resources</li> <li>Dependencies and their reliability</li> </ul> <p>By understanding these factors and using ewrap's features appropriately, you can build robust and maintainable error handling systems.</p>"},{"location":"features/error-creation/","title":"Error Creation","text":"<p>Understanding how to create errors effectively is fundamental to using the ewrap package. This guide explains the different ways to create errors and when to use each approach.</p>"},{"location":"features/error-creation/#basic-error-creation","title":"Basic Error Creation","text":"<p>The most straightforward way to create an error is using the <code>New</code> function. However, there's more to consider than just the error message.</p> <pre><code>// Simple error creation\nerr := ewrap.New(\"user not found\")\n\n// With additional context\nerr := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError),\n    ewrap.WithLogger(logger))\n</code></pre> <p>The <code>New</code> function captures a stack trace automatically, allowing you to trace the error's origin later. This is particularly valuable when debugging complex applications where errors might surface far from their source.</p>"},{"location":"features/error-creation/#creating-errors-with-options","title":"Creating Errors with Options","text":"<p>The <code>New</code> function accepts variadic options that configure the error's behavior and context:</p> <pre><code>err := ewrap.New(\"failed to process payment\",\n    // Add request context\n    ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical),\n    // Configure logging\n    ewrap.WithLogger(logger),\n    // Add retry information\n    ewrap.WithRetry(3, time.Second*5))\n</code></pre> <p>Each option serves a specific purpose:</p> <ul> <li><code>WithContext</code>: Adds request context and error classification</li> <li><code>WithLogger</code>: Configures error logging behavior</li> <li><code>WithRetry</code>: Specifies retry behavior for recoverable errors</li> </ul>"},{"location":"features/error-creation/#creating-domain-specific-errors","title":"Creating Domain-Specific Errors","text":"<p>For domain-specific error cases, you can combine error creation with metadata:</p> <pre><code>func validateUserAge(age int) error {\n    if age &lt; 18 {\n        return ewrap.New(\"user is underage\",\n            ewrap.WithContext(context.Background(), ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"minimum_age\", 18).\n            WithMetadata(\"provided_age\", age)\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-creation/#best-practices-for-error-creation","title":"Best Practices for Error Creation","text":"<p>When creating errors, follow these guidelines for maximum effectiveness:</p> <ol> <li> <p>Be Specific: Error messages should clearly indicate what went wrong:</p> <pre><code>// Good\nerr := ewrap.New(\"database connection timeout after 5 seconds\")\n\n// Not as helpful\nerr := ewrap.New(\"database error\")\n</code></pre> </li> <li> <p>Include Relevant Context: Add context that helps with debugging:</p> <pre><code>err := ewrap.New(\"failed to update user profile\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError)).\n    WithMetadata(\"user_id\", userID).\n    WithMetadata(\"fields_updated\", fields)\n</code></pre> </li> <li> <p>Use Appropriate Error Types: Choose error types that match the situation:</p> <pre><code>// For validation errors\nerr := ewrap.New(\"invalid email format\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityWarning))\n\n// For system errors\nerr := ewrap.New(\"failed to connect to database\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n</code></pre> </li> <li> <p>Consider Recovery Options: Include information that helps with recovery:</p> <pre><code>err := ewrap.New(\"rate limit exceeded\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityWarning)).\n    WithMetadata(\"retry_after\", time.Now().Add(time.Minute)).\n    WithMetadata(\"current_rate\", currentRate).\n    WithMetadata(\"limit\", rateLimit)\n</code></pre> </li> </ol>"},{"location":"features/error-creation/#working-with-stack-traces","title":"Working with Stack Traces","text":"<p>Every error created with <code>New</code> automatically captures a stack trace:</p> <pre><code>func processOrder(orderID string) error {\n    err := ewrap.New(\"order processing failed\")\n    fmt.Println(err.Stack()) // Prints the stack trace\n    return err\n}\n</code></pre> <p>The stack trace includes function names, file names, and line numbers, making it easier to trace the error's origin.</p>"},{"location":"features/error-creation/#error-creation-in-tests","title":"Error Creation in Tests","text":"<p>When writing tests, you might want to create errors for specific scenarios:</p> <pre><code>func TestOrderProcessing(t *testing.T) {\n    // Create a test error\n    testErr := ewrap.New(\"simulated database error\",\n        ewrap.WithContext(context.Background(), ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n\n    // Mock database returns our test error\n    mockDB := &amp;MockDatabase{\n        QueryFunc: func() error {\n            return testErr\n        },\n    }\n\n    err := processOrder(mockDB, \"order123\")\n\n    // Verify error handling\n    if !errors.Is(err, testErr) {\n        t.Errorf(\"expected error %v, got %v\", testErr, err)\n    }\n}\n</code></pre>"},{"location":"features/error-creation/#thread-safety","title":"Thread Safety","text":"<p>All error creation operations in ewrap are thread-safe. You can safely create errors from multiple goroutines:</p> <pre><code>func processItems(items []string) []error {\n    var wg sync.WaitGroup\n    errors := make([]error, 0)\n    var mu sync.Mutex\n\n    for _, item := range items {\n        wg.Add(1)\n        go func(item string) {\n            defer wg.Done()\n            if err := process(item); err != nil {\n                mu.Lock()\n                errors = append(errors, ewrap.New(\"processing failed\",\n                    ewrap.WithMetadata(\"item\", item)))\n                mu.Unlock()\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return errors\n}\n</code></pre>"},{"location":"features/error-creation/#performance-considerations","title":"Performance Considerations","text":"<p>Error creation in ewrap is optimized for both CPU and memory usage. However, consider these performance tips:</p> <ol> <li>Reuse error types for common errors instead of creating new ones</li> <li>Only capture stack traces when necessary</li> <li>Be mindful of metadata quantity in high-throughput scenarios</li> <li>Use error pools for frequent error creation scenarios</li> </ol> <p>Remember: error creation should be reserved for exceptional cases. Don't use errors for normal control flow in your application.</p>"},{"location":"features/error-wrapping/","title":"Error Wrapping","text":"<p>Error wrapping is a powerful feature that allows you to add context to errors as they propagate through your application. Understanding how to effectively wrap errors can significantly improve your application's debuggability and error handling capabilities.</p>"},{"location":"features/error-wrapping/#understanding-error-wrapping","title":"Understanding Error Wrapping","text":"<p>When an error occurs deep in your application's call stack, it often needs to pass through several layers before being handled. Each layer might need to add its own context to the error, helping to tell the complete story of what went wrong.</p> <p>Consider this scenario:</p> <pre><code>func getUserProfile(userID string) (*Profile, error) {\n    // Low level database error occurs\n    data, err := db.Query(\"SELECT * FROM users WHERE id = ?\", userID)\n    if err != nil {\n        // We wrap the database error with our context\n        return nil, ewrap.Wrap(err, \"failed to fetch user data\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    // Error occurs during data processing\n    profile, err := parseUserData(data)\n    if err != nil {\n        // We wrap the parsing error with additional context\n        return nil, ewrap.Wrap(err, \"failed to parse user profile\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)).\n            WithMetadata(\"user_id\", userID)\n    }\n\n    return profile, nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#the-wrap-function","title":"The Wrap Function","text":"<p>The <code>Wrap</code> function is the primary tool for error wrapping. It preserves the original error while adding new context:</p> <pre><code>func Wrap(err error, msg string, opts ...Option) *Error\n</code></pre> <p>The function takes:</p> <ul> <li>The original error</li> <li>A message describing what went wrong at this level</li> <li>Optional configuration options</li> </ul>"},{"location":"features/error-wrapping/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of error wrapping:</p> <pre><code>if err := validateInput(data); err != nil {\n    return ewrap.Wrap(err, \"input validation failed\")\n}\n</code></pre>"},{"location":"features/error-wrapping/#adding-context-while-wrapping","title":"Adding Context While Wrapping","text":"<p>You can add rich context while wrapping errors:</p> <pre><code>if err := processPayment(amount); err != nil {\n    return ewrap.Wrap(err, \"payment processing failed\",\n        ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityCritical),\n        ewrap.WithLogger(logger)).\n        WithMetadata(\"amount\", amount).\n        WithMetadata(\"currency\", \"USD\").\n        WithMetadata(\"processor\", \"stripe\")\n}\n</code></pre>"},{"location":"features/error-wrapping/#error-chain-preservation","title":"Error Chain Preservation","text":"<p>When you wrap an error, ewrap maintains the entire error chain. This means you can:</p> <ul> <li>Access the original error</li> <li>See all intermediate wrapping contexts</li> <li>Understand the complete error path</li> </ul> <pre><code>func main() {\n    err := processUserRequest()\n    if err != nil {\n        // Print the full error chain\n        fmt.Println(err)\n\n        // Access the root cause\n        cause := errors.Unwrap(err)\n\n        // Check if a specific error type exists in the chain\n        if errors.Is(err, sql.ErrNoRows) {\n            // Handle database not found case\n        }\n    }\n}\n</code></pre>"},{"location":"features/error-wrapping/#formatted-wrapping-with-wrapf","title":"Formatted Wrapping with Wrapf","text":"<p>For cases where you need to include formatted messages, use <code>Wrapf</code>:</p> <pre><code>func updateUser(userID string, fields map[string]interface{}) error {\n    if err := db.Update(userID, fields); err != nil {\n        return ewrap.Wrapf(err, \"failed to update user %s\", userID)\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#best-practices-for-error-wrapping","title":"Best Practices for Error Wrapping","text":""},{"location":"features/error-wrapping/#1-add-meaningful-context","title":"1. Add Meaningful Context","text":"<p>Each wrap should add valuable information:</p> <pre><code>// Good - adds specific context\nerr = ewrap.Wrap(err, \"failed to process monthly report for January 2024\",\n    ewrap.WithMetadata(\"report_type\", \"monthly\"),\n    ewrap.WithMetadata(\"period\", \"2024-01\"))\n\n// Not as helpful - too generic\nerr = ewrap.Wrap(err, \"processing failed\")\n</code></pre>"},{"location":"features/error-wrapping/#2-preserve-error-types","title":"2. Preserve Error Types","text":"<p>Choose error types that make sense for the current context:</p> <pre><code>func validateAndSaveUser(user User) error {\n    err := validateUser(user)\n    if err != nil {\n        // Preserve validation error type\n        return ewrap.Wrap(err, \"user validation failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityError))\n    }\n\n    err = saveUser(user)\n    if err != nil {\n        // Use database error type for storage issues\n        return ewrap.Wrap(err, \"failed to save user\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#3-use-appropriate-granularity","title":"3. Use Appropriate Granularity","text":"<p>Balance between too much and too little information:</p> <pre><code>func processOrder(order Order) error {\n    // Wrap high-level business operations\n    if err := validateOrder(order); err != nil {\n        return ewrap.Wrap(err, \"order validation failed\")\n    }\n\n    // Don't wrap every small utility function\n    total := calculateTotal(order.Items)\n\n    // Wrap significant state transitions or external calls\n    if err := chargeCustomer(order.CustomerID, total); err != nil {\n        return ewrap.Wrap(err, \"payment processing failed\",\n            ewrap.WithMetadata(\"amount\", total),\n            ewrap.WithMetadata(\"customer_id\", order.CustomerID))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#4-consider-performance","title":"4. Consider Performance","text":"<p>While error wrapping is lightweight, be mindful in hot paths:</p> <pre><code>func processItems(items []Item) error {\n    for _, item := range items {\n        // In tight loops, consider if wrapping is necessary\n        if err := validateItem(item); err != nil {\n            return err  // Maybe don't wrap simple validation errors\n        }\n\n        // Do wrap significant errors\n        if err := processItem(item); err != nil {\n            return ewrap.Wrap(err, \"item processing failed\",\n                ewrap.WithMetadata(\"item_id\", item.ID))\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#advanced-error-wrapping","title":"Advanced Error Wrapping","text":""},{"location":"features/error-wrapping/#conditional-wrapping","title":"Conditional Wrapping","text":"<p>Sometimes you might want to wrap errors differently based on their type:</p> <pre><code>func handleDatabaseOperation() error {\n    err := db.Query()\n    if err != nil {\n        switch {\n        case errors.Is(err, sql.ErrNoRows):\n            return ewrap.Wrap(err, \"record not found\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityWarning))\n        case errors.Is(err, sql.ErrConnDone):\n            return ewrap.Wrap(err, \"database connection lost\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n        default:\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#multi-level-wrapping","title":"Multi-Level Wrapping","text":"<p>For complex operations, you might wrap errors multiple times:</p> <pre><code>func processUserOrder(ctx context.Context, userID, orderID string) error {\n    user, err := getUser(userID)\n    if err != nil {\n        return ewrap.Wrap(err, \"failed to get user\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    order, err := getOrder(orderID)\n    if err != nil {\n        return ewrap.Wrap(err, \"failed to get order\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    if err := validateUserCanAccessOrder(user, order); err != nil {\n        return ewrap.Wrap(err, \"user not authorized to access order\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypePermission, ewrap.SeverityWarning))\n    }\n\n    if err := processOrderPayment(order); err != nil {\n        return ewrap.Wrap(err, \"order payment failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityCritical))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/","title":"Stack Traces","text":"<p>Stack traces are crucial for understanding where and why errors occur in your application. In ewrap, stack traces are automatically captured and enhanced to provide meaningful debugging information while maintaining performance.</p>"},{"location":"features/stack-traces/#understanding-stack-traces","title":"Understanding Stack Traces","text":"<p>A stack trace represents the sequence of function calls that led to an error. Think of it as a trail of breadcrumbs showing exactly how your program reached a particular point of failure. ewrap captures this information automatically while filtering out unnecessary noise.</p>"},{"location":"features/stack-traces/#how-ewrap-captures-stack-traces","title":"How ewrap Captures Stack Traces","text":"<p>When you create a new error using ewrap, it automatically captures the current stack trace:</p> <pre><code>func processUserData(userID string) error {\n    // This will capture the stack trace automatically\n    if err := validateUser(userID); err != nil {\n        return ewrap.New(\"user validation failed\")\n    }\n    return nil\n}\n</code></pre> <p>The captured stack trace includes:</p> <ul> <li>Function names</li> <li>File names</li> <li>Line numbers</li> <li>Package information</li> </ul> <p>However, ewrap goes beyond simple capture by:</p> <ol> <li>Filtering out runtime implementation details</li> <li>Maintaining stack traces through error wrapping</li> <li>Providing formatted output options</li> </ol>"},{"location":"features/stack-traces/#accessing-stack-traces","title":"Accessing Stack Traces","text":"<p>You can access the stack trace of an error in several ways:</p> <pre><code>func handleError(err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Get the full stack trace as a string\n        stackTrace := wrappedErr.Stack()\n\n        fmt.Printf(\"Error occurred: %v\\n\", err)\n        fmt.Printf(\"Stack trace:\\n%s\", stackTrace)\n    }\n}\n</code></pre> <p>When working with JSON output:</p> <pre><code>err := ewrap.New(\"database connection failed\")\njsonOutput, _ := err.ToJSON(ewrap.WithStackTrace(true))\nfmt.Println(jsonOutput)\n</code></pre>"},{"location":"features/stack-traces/#stack-trace-filtering","title":"Stack Trace Filtering","text":"<p>ewrap automatically filters stack traces to remove unhelpful information. Consider this example:</p> <pre><code>func getUserProfile(id string) (*Profile, error) {\n    profile, err := db.GetProfile(id)\n    if err != nil {\n        // The stack trace will exclude runtime internals\n        return nil, ewrap.Wrap(err, \"failed to retrieve user profile\")\n    }\n    return profile, nil\n}\n</code></pre> <p>The resulting stack trace might look like this:</p> <pre><code>/app/services/user.go:25 - getUserProfile\n/app/handlers/profile.go:42 - HandleProfileRequest\n/app/router/routes.go:156 - ServeHTTP\n</code></pre> <p>Instead of the more verbose and less helpful unfiltered version:</p> <pre><code>/app/services/user.go:25 - getUserProfile\n/app/handlers/profile.go:42 - HandleProfileRequest\n/app/router/routes.go:156 - ServeHTTP\n/usr/local/go/src/runtime/asm_amd64.s:1571 - goexit\n/usr/local/go/src/runtime/proc.go:203 - main\n...\n</code></pre>"},{"location":"features/stack-traces/#stack-traces-in-error-chains","title":"Stack Traces in Error Chains","text":"<p>When you wrap errors, ewrap preserves the original stack trace while maintaining the error chain:</p> <pre><code>func processOrder(orderID string) error {\n    // Original error with its stack trace\n    err := validateOrder(orderID)\n    if err != nil {\n        // Wraps the error while preserving the original stack trace\n        return ewrap.Wrap(err, \"order validation failed\")\n    }\n\n    err = saveOrder(orderID)\n    if err != nil {\n        // Each wrap maintains the complete error context\n        return ewrap.Wrap(err, \"failed to save order\")\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/#performance-considerations","title":"Performance Considerations","text":"<p>While stack traces are valuable for debugging, they do come with some overhead. ewrap optimizes this by:</p> <ol> <li>Using efficient stack capture mechanisms</li> <li>Implementing lazy formatting</li> <li>Caching stack trace strings</li> <li>Filtering irrelevant frames early</li> </ol> <p>Here's how to work with stack traces efficiently:</p> <pre><code>func processItems(items []Item) error {\n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            // In tight loops, consider whether you need the stack trace\n            if isCriticalError(err) {\n                return ewrap.Wrap(err, \"critical error during item processing\")\n            }\n            // For non-critical errors, maybe just log and continue\n            log.Printf(\"Non-critical error: %v\", err)\n            continue\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/#using-stack-traces-for-debugging","title":"Using Stack Traces for Debugging","text":"<p>Stack traces are most valuable when combined with other error context. Here's a comprehensive example:</p> <pre><code>func debugError(err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        fmt.Printf(\"Error Message: %v\\n\", wrappedErr.Error())\n\n        // Print the stack trace\n        fmt.Printf(\"\\nStack Trace:\\n%s\\n\", wrappedErr.Stack())\n\n        // Get any metadata\n        if metadata, ok := wrappedErr.GetMetadata(\"request_id\"); ok {\n            fmt.Printf(\"\\nRequest ID: %v\\n\", metadata)\n        }\n\n        // Print error chain\n        fmt.Println(\"\\nError Chain:\")\n        for e := wrappedErr; e != nil; e = e.Unwrap().(*ewrap.Error) {\n            fmt.Printf(\"- %s\\n\", e.Error())\n        }\n    }\n}\n</code></pre>"},{"location":"features/stack-traces/#best-practices-for-stack-traces","title":"Best Practices for Stack Traces","text":"<ol> <li> <p>Keep Stack Traces Meaningful</p> <p>In service handlers, capture enough context without excessive detail:</p> <pre><code>func (s *Service) HandleRequest(ctx context.Context, req Request) error {\n    // Capture high-level service context\n    if err := s.processRequest(ctx, req); err != nil {\n        return ewrap.Wrap(err, \"request processing failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError))\n    }\n    return nil\n}\n</code></pre> </li> <li> <p>Combine with Logging</p> <p>Integrate stack traces with your logging system:</p> <pre><code>func logError(err error, logger Logger) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        logger.Error(\"operation failed\",\n            \"error\", wrappedErr.Error(),\n            \"stack\", wrappedErr.Stack(),\n            \"type\", ewrap.GetErrorType(wrappedErr))\n    }\n}\n</code></pre> </li> <li> <p>Use in Development and Testing</p> <p>Stack traces are particularly valuable during development and testing:</p> <pre><code>func TestComplexOperation(t *testing.T) {\n    err := performComplexOperation()\n    if err != nil {\n        t.Errorf(\"Operation failed with stack trace:\\n%+v\", err)\n    }\n}\n</code></pre> </li> </ol>"},{"location":"features/stack-traces/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"<ol> <li> <p>Stack Trace Depth</p> <p>If you're seeing too much or too little information:</p> <pre><code>// Too much information\nerr := ewrap.New(\"operation failed\")\n\n// Just right - wrap with context\nerr := ewrap.New(\"operation failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)).\n    WithMetadata(\"operation\", \"user_update\")\n</code></pre> </li> <li> <p>Missing Context</p> </li> </ol> <p>Ensure you're capturing relevant context with your stack traces:</p> <pre><code>func handleRequest(ctx context.Context, req *Request) error {\n    if err := validateRequest(req); err != nil {\n        // Include request context with the stack trace\n        return ewrap.Wrap(err, \"invalid request\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"request_id\", req.ID).\n            WithMetadata(\"user_id\", req.UserID)\n    }\n    return nil\n}\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with ewrap quickly. We'll cover the basic concepts and show you how to use the main features of the package.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#creating-errors","title":"Creating Errors","text":"<p>The simplest way to create an error with ewrap is using the <code>New</code> function:</p> <pre><code>err := ewrap.New(\"something went wrong\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-context","title":"Adding Context","text":"<p>You can add context to your errors using various options:</p> <pre><code>err := ewrap.New(\"database connection failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger))\n</code></pre>"},{"location":"getting-started/quickstart/#wrapping-errors","title":"Wrapping Errors","text":"<p>When you want to add context to an existing error:</p> <pre><code>if err != nil {\n    return ewrap.Wrap(err, \"failed to process request\")\n}\n</code></pre>"},{"location":"getting-started/quickstart/#using-error-groups","title":"Using Error Groups","text":"<p>Error groups help you collect and manage multiple errors:</p> <pre><code>// Create an error group pool\npool := ewrap.NewErrorGroupPool(4)\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Don't forget to release it back to the pool\n\n// Add errors as needed\neg.Add(err1)\neg.Add(err2)\n\nif eg.HasErrors() {\n    return eg.Error()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#implementing-circuit-breaker","title":"Implementing Circuit Breaker","text":"<p>Protect your system from cascading failures:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\nif cb.CanExecute() {\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()\n        return err\n    }\n    cb.RecordSuccess()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ol> <li>Learn about Error Types</li> <li>Explore Logging Integration</li> <li>Study Advanced Usage</li> <li>Check out complete Examples</li> </ol>"},{"location":"getting-started/quickstart/#best-practices","title":"Best Practices","text":"<p>Here are some best practices to follow when using ewrap:</p> <ol> <li>Always provide meaningful error messages</li> <li>Use appropriate error types and severity levels</li> <li>Release error groups back to their pools</li> <li>Configure circuit breakers based on your system's characteristics</li> <li>Implement proper logging integration</li> <li>Use metadata to add relevant debugging information</li> </ol>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you might find useful:</p> <pre><code>func processItem(ctx context.Context, item string) error {\n    // Create error group from pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate input\n    if err := validate(item); err != nil {\n        eg.Add(ewrap.Wrap(err, \"validation failed\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Process if no validation errors\n    if !eg.HasErrors() {\n        if err := process(item); err != nil {\n            return ewrap.Wrap(err, \"processing failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeInternal))\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre> <p>This is just a starting point. For more detailed information about specific features, check out the relevant sections in the documentation.</p>"}]}