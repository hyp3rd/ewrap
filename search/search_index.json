{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ewrap Documentation","text":"<p>Welcome to the documentation for <code>ewrap</code>, a sophisticated error handling package for Go applications that provides comprehensive error management capabilities with a focus on performance and developer experience.</p>"},{"location":"#overview","title":"Overview","text":"<p>ewrap is designed to make error handling in Go applications more robust, informative, and maintainable. It provides a rich set of features while maintaining excellent performance characteristics through careful optimization and efficient memory management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stack Traces: Automatically capture and filter stack traces for meaningful error debugging</li> <li>Error Wrapping: Maintain error chains while preserving context</li> <li>Metadata Attachment: Attach and manage arbitrary key-value pairs to errors</li> <li>Logging Integration: Flexible logger interface supporting major logging frameworks</li> <li>Error Categorization: Built-in error types and severity levels</li> <li>Circuit Breaker Pattern: Protect your systems from cascading failures</li> <li>Efficient Error Grouping: Pool-based error group management</li> <li>Context Preservation: Rich error context preservation</li> <li>Thread-Safe Operations: Safe for concurrent use</li> <li>Format Options: JSON and YAML output support</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a quick example of how ewrap can be used in your application:</p> <pre><code>func processOrder(ctx context.Context, orderID string) error {\n    // Get an error group from the pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Create a circuit breaker\n    cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\n    // Add validation errors to the group\n    if err := validateOrder(orderID); err != nil {\n        eg.Add(ewrap.Wrap(err, \"invalid order\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation),\n            ewrap.WithLogger(logger)))\n    }\n\n    // Handle database operations with circuit breaker\n    if !eg.HasErrors() &amp;&amp; cb.CanExecute() {\n        if err := saveToDatabase(orderID); err != nil {\n            cb.RecordFailure()\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n                ewrap.WithRetry(3, time.Second*5))\n        }\n        cb.RecordSuccess()\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To start using ewrap in your project, visit the Installation guide, followed by the Quick Start tutorial.</p>"},{"location":"#why-ewrap","title":"Why ewrap?","text":"<p>ewrap was created to address common challenges in error handling:</p> <ol> <li>Lack of Context: Traditional error handling often loses important context</li> <li>Performance Overhead: Many error handling libraries introduce significant overhead</li> <li>Memory Management: Poor memory management in error handling can lead to increased GC pressure</li> <li>Inconsistent Logging: Different parts of an application often handle error logging differently</li> <li>Missing Stack Traces: Getting meaningful stack traces can be challenging</li> <li>Circuit Breaking: Protecting systems from cascading failures requires complex implementation</li> </ol> <p>ewrap solves these challenges while maintaining excellent performance characteristics and providing a clean, intuitive API.</p>"},{"location":"advanced/context/","title":"Context Integration","text":"<p>Understanding how to effectively integrate error handling with Go's context package is crucial for building robust, context-aware applications. Context integration allows us to carry request-scoped data, handle timeouts gracefully, and maintain traceability throughout our application's error handling flow.</p>"},{"location":"advanced/context/#understanding-context-in-error-handling","title":"Understanding Context in Error Handling","text":"<p>Go's context package serves multiple purposes in error handling:</p> <ul> <li>Carrying request-scoped values (like request IDs or user information)</li> <li>Managing timeouts and cancellation</li> <li>Ensuring proper resource cleanup</li> <li>Maintaining traceability across service boundaries</li> </ul> <p>Let's explore how ewrap integrates with context to enhance error handling capabilities.</p>"},{"location":"advanced/context/#basic-context-integration","title":"Basic Context Integration","text":"<p>The most straightforward way to integrate context with error handling is through the WithContext option:</p> <pre><code>func processUserRequest(ctx context.Context, userID string) error {\n    // Create an error with context\n    if err := validateUser(userID); err != nil {\n        return ewrap.Wrap(err, \"user validation failed\",\n            ewrap.WithContext(ctx, ErrorTypeValidation, SeverityError))\n    }\n\n    return nil\n}\n</code></pre> <p>When you add context to an error, ewrap automatically extracts and preserves important context values such as:</p> <ul> <li>Request IDs for tracing</li> <li>User information for auditing</li> <li>Operation metadata for monitoring</li> <li>Timing information for performance tracking</li> </ul>"},{"location":"advanced/context/#advanced-context-usage","title":"Advanced Context Usage","text":"<p>Let's look at more sophisticated ways to use context in error handling:</p> <pre><code>// Define context keys for common values\ntype contextKey string\n\nconst (\n    requestIDKey contextKey = \"request_id\"\n    userIDKey    contextKey = \"user_id\"\n    traceIDKey   contextKey = \"trace_id\"\n)\n\n// RequestContext enriches context with standard fields\nfunc RequestContext(ctx context.Context, requestID, userID string) context.Context {\n    ctx = context.WithValue(ctx, requestIDKey, requestID)\n    ctx = context.WithValue(ctx, userIDKey, userID)\n    ctx = context.WithValue(ctx, traceIDKey, generateTraceID())\n    return ctx\n}\n\n// ContextualOperation shows how to use context throughout an operation\nfunc ContextualOperation(ctx context.Context) error {\n    // Extract context values\n    requestID := ctx.Value(requestIDKey).(string)\n    userID := ctx.Value(userIDKey).(string)\n\n    // Create an operation-specific context\n    opCtx := ewrap.WithOperationContext(ctx, \"user_update\")\n\n    // Start a timed operation\n    timer := time.Now()\n\n    // Perform the operation with timeout\n    if err := performTimedOperation(opCtx); err != nil {\n        return ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithContext(ctx, ErrorTypeInternal, SeverityError)).\n            WithMetadata(\"request_id\", requestID).\n            WithMetadata(\"user_id\", userID).\n            WithMetadata(\"duration_ms\", time.Since(timer).Milliseconds())\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"advanced/context/#context-aware-error-groups","title":"Context-Aware Error Groups","text":"<p>Error groups can be made context-aware to handle cancellation and timeouts:</p> <pre><code>// ContextualErrorGroup manages errors with context awareness\ntype ContextualErrorGroup struct {\n    *ewrap.ErrorGroup\n    ctx context.Context\n}\n\n// NewContextualErrorGroup creates a context-aware error group\nfunc NewContextualErrorGroup(ctx context.Context, pool *ewrap.ErrorGroupPool) *ContextualErrorGroup {\n    return &amp;ContextualErrorGroup{\n        ErrorGroup: pool.Get(),\n        ctx:       ctx,\n    }\n}\n\n// ProcessWithContext demonstrates context-aware parallel processing\nfunc ProcessWithContext(ctx context.Context, items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    group := NewContextualErrorGroup(ctx, pool)\n    defer group.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n\n            // Check context cancellation\n            select {\n            case &lt;-ctx.Done():\n                group.Add(ewrap.New(\"operation cancelled\",\n                    ewrap.WithContext(ctx, ErrorTypeInternal, SeverityWarning)))\n                return\n            default:\n                if err := processItem(ctx, item); err != nil {\n                    group.Add(err)\n                }\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return group.Error()\n}\n</code></pre>"},{"location":"advanced/context/#timeout-and-cancellation-handling","title":"Timeout and Cancellation Handling","text":"<p>Proper context integration includes handling timeouts and cancellation gracefully:</p> <pre><code>// TimeoutAwareOperation shows how to handle context timeouts\nfunc TimeoutAwareOperation(ctx context.Context) error {\n    // Create a timeout context\n    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)\n    defer cancel()\n\n    // Channel for operation result\n    resultCh := make(chan error, 1)\n\n    // Start the operation\n    go func() {\n        resultCh &lt;- performLongOperation(ctx)\n    }()\n\n    // Wait for result or timeout\n    select {\n    case err := &lt;-resultCh:\n        if err != nil {\n            return ewrap.Wrap(err, \"operation failed\",\n                ewrap.WithContext(ctx, ErrorTypeInternal, SeverityError))\n        }\n        return nil\n    case &lt;-ctx.Done():\n        return ewrap.New(\"operation timed out\",\n            ewrap.WithContext(ctx, ErrorTypeTimeout, SeverityCritical)).\n            WithMetadata(\"timeout\", 5*time.Second)\n    }\n}\n</code></pre>"},{"location":"advanced/context/#context-propagation-in-middleware","title":"Context Propagation in Middleware","text":"<p>Context integration is particularly useful in middleware chains:</p> <pre><code>// ErrorHandlingMiddleware demonstrates context propagation\nfunc ErrorHandlingMiddleware(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // Create request context with tracing\n        ctx := r.Context()\n        requestID := generateRequestID()\n        ctx = context.WithValue(ctx, requestIDKey, requestID)\n\n        // Create error group for request\n        pool := ewrap.NewErrorGroupPool(4)\n        eg := pool.Get()\n        defer eg.Release()\n\n        // Wrap handler execution\n        err := func() error {\n            // Add request timing\n            timer := time.Now()\n            defer func() {\n                if err := recover(); err != nil {\n                    eg.Add(ewrap.New(\"panic in handler\",\n                        ewrap.WithContext(ctx, ErrorTypeInternal, SeverityCritical)).\n                        WithMetadata(\"panic_value\", err).\n                        WithMetadata(\"stack\", debug.Stack()))\n                }\n            }()\n\n            // Execute handler\n            next.ServeHTTP(w, r.WithContext(ctx))\n\n            // Record timing\n            duration := time.Since(timer)\n            if duration &gt; time.Second {\n                eg.Add(ewrap.New(\"slow request\",\n                    ewrap.WithContext(ctx, ErrorTypePerformance, SeverityWarning)).\n                    WithMetadata(\"duration_ms\", duration.Milliseconds()))\n            }\n\n            return nil\n        }()\n\n        if err != nil {\n            eg.Add(err)\n        }\n\n        // Handle any collected errors\n        if eg.HasErrors() {\n            handleRequestErrors(w, eg.Error())\n        }\n    })\n}\n</code></pre>"},{"location":"advanced/context/#best-practices","title":"Best Practices","text":""},{"location":"advanced/context/#1-consistent-context-propagation","title":"1. Consistent Context Propagation","text":"<p>Maintain consistent context handling throughout your application:</p> <pre><code>// ContextualService demonstrates consistent context handling\ntype ContextualService struct {\n    db  *Database\n    log Logger\n}\n\nfunc (s *ContextualService) ProcessRequest(ctx context.Context, req Request) error {\n    // Enrich context with request information\n    ctx = enrichContext(ctx, req)\n\n    // Use context in all operations\n    if err := s.validateRequest(ctx, req); err != nil {\n        return ewrap.Wrap(err, \"validation failed\",\n            ewrap.WithContext(ctx, ErrorTypeValidation, SeverityError))\n    }\n\n    if err := s.processData(ctx, req.Data); err != nil {\n        return ewrap.Wrap(err, \"processing failed\",\n            ewrap.WithContext(ctx, ErrorTypeInternal, SeverityError))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"advanced/context/#2-context-value-management","title":"2. Context Value Management","text":"<p>Be careful with context values and provide type-safe accessors:</p> <pre><code>// RequestInfo holds request-specific context values\ntype RequestInfo struct {\n    RequestID string\n    UserID    string\n    TraceID   string\n    StartTime time.Time\n}\n\n// GetRequestInfo safely extracts request information from context\nfunc GetRequestInfo(ctx context.Context) (RequestInfo, bool) {\n    info, ok := ctx.Value(requestInfoKey).(RequestInfo)\n    return info, ok\n}\n\n// WithRequestInfo adds request information to context\nfunc WithRequestInfo(ctx context.Context, info RequestInfo) context.Context {\n    return context.WithValue(ctx, requestInfoKey, info)\n}\n</code></pre>"},{"location":"advanced/context/#3-error-context-enrichment","title":"3. Error Context Enrichment","text":"<p>Systematically enrich errors with context information:</p> <pre><code>// EnrichError adds standard context information to errors\nfunc EnrichError(ctx context.Context, err error) error {\n    if err == nil {\n        return nil\n    }\n\n    info, ok := GetRequestInfo(ctx)\n    if !ok {\n        return err\n    }\n\n    return ewrap.Wrap(err, \"operation failed\",\n        ewrap.WithContext(ctx, getErrorType(err), getSeverity(err))).\n        WithMetadata(\"request_id\", info.RequestID).\n        WithMetadata(\"user_id\", info.UserID).\n        WithMetadata(\"trace_id\", info.TraceID).\n        WithMetadata(\"duration_ms\", time.Since(info.StartTime).Milliseconds())\n}\n</code></pre> <p>The context integration in ewrap provides a robust foundation for error tracking and debugging. By consistently using these features, you can build applications that are easier to monitor, debug, and maintain.</p>"},{"location":"advanced/error-strategies/","title":"Error Handling Strategies","text":"<p>Understanding how to effectively handle errors is crucial for building robust applications. This guide explores various error handling strategies using ewrap and explains when to use each approach.</p>"},{"location":"advanced/error-strategies/#understanding-error-context","title":"Understanding Error Context","text":"<p>Error context is more than just an error message - it's the complete picture of what happened when an error occurred. With ewrap, you can capture rich context that helps with debugging and error resolution.</p>"},{"location":"advanced/error-strategies/#basic-context","title":"Basic Context","text":"<p>At its simplest, context includes:</p> <pre><code>err := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError))\n</code></pre> <p>This tells us:</p> <ul> <li>What happened (\"user not found\")</li> <li>The type of error (NotFound)</li> <li>How severe the error is (Error level)</li> </ul>"},{"location":"advanced/error-strategies/#enhanced-context","title":"Enhanced Context","text":"<p>For more complex scenarios, you can add detailed context:</p> <pre><code>err := ewrap.New(\"database query failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger)).\n    WithMetadata(\"query\", query).\n    WithMetadata(\"table\", \"users\").\n    WithMetadata(\"affected_rows\", 0).\n    WithMetadata(\"latency_ms\", queryTime.Milliseconds())\n</code></pre> <p>This provides a complete picture:</p> <ul> <li>The operation that failed</li> <li>Where it failed</li> <li>Related technical details</li> <li>Performance metrics</li> </ul>"},{"location":"advanced/error-strategies/#error-group-strategies","title":"Error Group Strategies","text":"<p>Error groups are powerful tools for handling multiple potential errors in a single operation. Here's how to use them effectively:</p>"},{"location":"advanced/error-strategies/#validation-scenarios","title":"Validation Scenarios","text":"<p>When validating multiple fields or conditions:</p> <pre><code>func validateUser(user User) error {\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate email\n    if !isValidEmail(user.Email) {\n        eg.Add(ewrap.New(\"invalid email format\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate age\n    if user.Age &lt; 18 {\n        eg.Add(ewrap.New(\"user must be 18 or older\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate username\n    if len(user.Username) &lt; 3 {\n        eg.Add(ewrap.New(\"username too short\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#parallel-operations","title":"Parallel Operations","text":"<p>When handling concurrent operations:</p> <pre><code>func processItems(ctx context.Context, items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            if err := processItem(ctx, item); err != nil {\n                eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#circuit-breaker-patterns","title":"Circuit Breaker Patterns","text":"<p>Circuit breakers help prevent system overload by failing fast when problems are detected. Here are some patterns for using them effectively:</p>"},{"location":"advanced/error-strategies/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<p>For simple protection:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 5, time.Minute)\n\nfunc queryDatabase() error {\n    if !cb.CanExecute() {\n        return ewrap.New(\"circuit breaker open\",\n            ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n            ewrap.WithMetadata(\"breaker\", \"database\"))\n    }\n\n    if err := performQuery(); err != nil {\n        cb.RecordFailure()\n        return err\n    }\n\n    cb.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"advanced/error-strategies/#cascading-circuit-breakers","title":"Cascading Circuit Breakers","text":"<p>For systems with dependencies:</p> <pre><code>type Service struct {\n    dbBreaker    *ewrap.CircuitBreaker\n    cacheBreaker *ewrap.CircuitBreaker\n    apiBreaker   *ewrap.CircuitBreaker\n}\n\nfunc (s *Service) getData(ctx context.Context, id string) (Data, error) {\n    // Try cache first\n    if s.cacheBreaker.CanExecute() {\n        data, err := queryCache(id)\n        if err == nil {\n            s.cacheBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.cacheBreaker.RecordFailure()\n    }\n\n    // Fall back to database\n    if s.dbBreaker.CanExecute() {\n        data, err := queryDatabase(id)\n        if err == nil {\n            s.dbBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.dbBreaker.RecordFailure()\n    }\n\n    // Last resort: external API\n    if s.apiBreaker.CanExecute() {\n        data, err := queryAPI(id)\n        if err == nil {\n            s.apiBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.apiBreaker.RecordFailure()\n    }\n\n    return Data{}, ewrap.New(\"all data sources failed\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"advanced/error-strategies/#best-practices-for-error-recovery","title":"Best Practices for Error Recovery","text":"<p>When handling errors, consider implementing recovery strategies:</p> <ol> <li> <p>Graceful Degradation:</p> <pre><code>func getProductDetails(ctx context.Context, id string) (Product, error) {\n    var product Product\n\n    // Get core product data\n    data, err := getProductData(id)\n    if err != nil {\n        // Log the error but continue with partial data\n        logger.Error(\"failed to get full product data\", \"error\", err)\n        product.Status = \"partial\"\n    } else {\n        product.Status = \"complete\"\n    }\n\n    // Get non-critical enrichment data\n    reviews, err := getProductReviews(id)\n    if err != nil {\n        // Add metadata about missing data\n        err = ewrap.Wrap(err, \"failed to get reviews\",\n            ewrap.WithMetadata(\"missing_component\", \"reviews\"),\n            ewrap.WithErrorType(ewrap.ErrorTypePartial))\n        logger.Warn(\"serving product without reviews\", \"error\", err)\n    }\n\n    return product, nil\n}\n</code></pre> </li> <li> <p>Retry Patterns:</p> </li> </ol> <pre><code>func withRetry(operation func() error, maxAttempts int, delay time.Duration) error {\n    var lastErr error\n\n    for attempt := 1; attempt &lt;= maxAttempts; attempt++ {\n        err := operation()\n        if err == nil {\n            return nil\n        }\n\n        lastErr = ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithMetadata(\"attempt\", attempt),\n            ewrap.WithMetadata(\"max_attempts\", maxAttempts))\n\n        if attempt &lt; maxAttempts {\n            time.Sleep(delay * time.Duration(attempt))\n        }\n    }\n\n    return lastErr\n}\n</code></pre> <p>The key to effective error handling is choosing the right strategy for each situation. Consider:</p> <ul> <li>The criticality of the operation</li> <li>Performance requirements</li> <li>User experience implications</li> <li>System resources</li> <li>Dependencies and their reliability</li> </ul> <p>By understanding these factors and using ewrap's features appropriately, you can build robust and maintainable error handling systems.</p>"},{"location":"advanced/error-types/","title":"Error Types","text":"<p>Error types in ewrap provide a structured way to categorize and handle different kinds of errors in your application. Understanding error types helps you make better decisions about error handling, logging, and recovery strategies.</p>"},{"location":"advanced/error-types/#understanding-error-types","title":"Understanding Error Types","text":"<p>Error types serve multiple purposes:</p> <ol> <li>They help categorize errors meaningfully</li> <li>They enable consistent error handling across your application</li> <li>They facilitate automated error processing and reporting</li> <li>They guide recovery strategies and user feedback</li> </ol> <p>Let's explore the built-in error types and learn how to use them effectively:</p> <pre><code>type ErrorType int\n\nconst (\n    ErrorTypeUnknown ErrorType = iota\n    ErrorTypeValidation\n    ErrorTypeNotFound\n    ErrorTypePermission\n    ErrorTypeDatabase\n    ErrorTypeNetwork\n    ErrorTypeConfiguration\n    ErrorTypeInternal\n    ErrorTypeExternal\n)\n</code></pre>"},{"location":"advanced/error-types/#using-error-types","title":"Using Error Types","text":"<p>Error types are most powerful when combined with context and metadata. Here's how to use them effectively:</p> <pre><code>func validateAndProcessUser(ctx context.Context, user User) error {\n    // Validation errors use ErrorTypeValidation\n    if err := validateUser(user); err != nil {\n        return ewrap.Wrap(err, \"user validation failed\",\n            ewrap.WithContext(ctx, ErrorTypeValidation, SeverityError)).\n            WithMetadata(\"validation_fields\", getFailedFields(err))\n    }\n\n    // Database errors use ErrorTypeDatabase\n    if err := saveUser(user); err != nil {\n        return ewrap.Wrap(err, \"failed to save user\",\n            ewrap.WithContext(ctx, ErrorTypeDatabase, SeverityCritical)).\n            WithMetadata(\"user_id\", user.ID)\n    }\n\n    // External service errors use ErrorTypeExternal\n    if err := notifyUserService(user); err != nil {\n        return ewrap.Wrap(err, \"failed to notify user service\",\n            ewrap.WithContext(ctx, ErrorTypeExternal, SeverityWarning)).\n            WithMetadata(\"service\", \"notification\")\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"advanced/error-types/#error-type-patterns","title":"Error Type Patterns","text":"<p>Different error types often require different handling strategies. Here's a comprehensive example:</p> <pre><code>func handleError(err error) {\n    wrappedErr, ok := err.(*ewrap.Error)\n    if !ok {\n        // Handle plain errors\n        return\n    }\n\n    ctx := getErrorContext(wrappedErr)\n    errorType := ctx.Type\n    severity := ctx.Severity\n\n    switch errorType {\n    case ErrorTypeValidation:\n        // Validation errors often need user feedback\n        handleValidationError(wrappedErr)\n\n    case ErrorTypeDatabase:\n        // Database errors might need retry logic\n        if severity == SeverityCritical {\n            notifyDatabaseAdmin(wrappedErr)\n        }\n        attemptDatabaseRecovery(wrappedErr)\n\n    case ErrorTypeNetwork:\n        // Network errors often benefit from circuit breaking\n        handleNetworkError(wrappedErr)\n\n    case ErrorTypePermission:\n        // Permission errors need security logging\n        logSecurityEvent(wrappedErr)\n\n    default:\n        // Unknown errors need investigation\n        logUnexpectedError(wrappedErr)\n    }\n}\n\nfunc handleValidationError(err *ewrap.Error) {\n    // Extract validation details for user feedback\n    fields, _ := err.GetMetadata(\"validation_fields\")\n    userMessage := buildUserFriendlyMessage(fields)\n\n    // Log for debugging but don't alert\n    logger.Debug(\"validation error occurred\",\n        \"fields\", fields,\n        \"user_message\", userMessage)\n}\n\nfunc handleDatabaseError(err *ewrap.Error) {\n    // Check if error is retryable\n    if isRetryableError(err) {\n        retryWithBackoff(func() error {\n            // Retry the operation\n            return nil\n        })\n    }\n\n    // Log critical database errors\n    logger.Error(\"database error occurred\",\n        \"error\", err,\n        \"stack\", err.Stack())\n}\n</code></pre>"},{"location":"advanced/error-types/#custom-error-types","title":"Custom Error Types","text":"<p>Sometimes you need domain-specific error types. Here's how to extend the system:</p> <pre><code>// Define custom error types\nconst (\n    ErrorTypePayment ErrorType = iota + 100  // Start after built-in types\n    ErrorTypeInventory\n    ErrorTypeShipping\n)\n\n// Create a type registry\ntype ErrorTypeRegistry struct {\n    types map[ErrorType]string\n    mu    sync.RWMutex\n}\n\nfunc NewErrorTypeRegistry() *ErrorTypeRegistry {\n    return &amp;ErrorTypeRegistry{\n        types: make(map[ErrorType]string),\n    }\n}\n\nfunc (r *ErrorTypeRegistry) Register(et ErrorType, name string) {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n    r.types[et] = name\n}\n\nfunc (r *ErrorTypeRegistry) GetName(et ErrorType) string {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    if name, ok := r.types[et]; ok {\n        return name\n    }\n    return \"unknown\"\n}\n\n// Usage example\nfunc initErrorTypes() *ErrorTypeRegistry {\n    registry := NewErrorTypeRegistry()\n\n    // Register custom error types\n    registry.Register(ErrorTypePayment, \"payment\")\n    registry.Register(ErrorTypeInventory, \"inventory\")\n    registry.Register(ErrorTypeShipping, \"shipping\")\n\n    return registry\n}\n</code></pre>"},{"location":"advanced/error-types/#error-type-best-practices","title":"Error Type Best Practices","text":""},{"location":"advanced/error-types/#1-consistent-type-assignment","title":"1. Consistent Type Assignment","text":"<p>Be consistent in how you assign error types:</p> <pre><code>// Good - consistent error typing\nfunc processOrder(order Order) error {\n    if err := validateOrder(order); err != nil {\n        return ewrap.Wrap(err, \"order validation failed\",\n            ewrap.WithErrorType(ErrorTypeValidation))\n    }\n\n    if err := checkInventory(order); err != nil {\n        return ewrap.Wrap(err, \"inventory check failed\",\n            ewrap.WithErrorType(ErrorTypeInventory))\n    }\n\n    if err := processPayment(order); err != nil {\n        return ewrap.Wrap(err, \"payment processing failed\",\n            ewrap.WithErrorType(ErrorTypePayment))\n    }\n\n    return nil\n}\n\n// Avoid - inconsistent or missing error types\nfunc processOrder(order Order) error {\n    if err := validateOrder(order); err != nil {\n        return fmt.Errorf(\"validation failed: %w\", err)\n    }\n    // ...\n}\n</code></pre>"},{"location":"advanced/error-types/#2-error-type-hierarchy","title":"2. Error Type Hierarchy","text":"<p>Consider creating error type hierarchies for complex domains:</p> <pre><code>// Define error type hierarchy\ntype ErrorCategory int\n\nconst (\n    CategoryValidation ErrorCategory = iota\n    CategoryInfrastructure\n    CategoryBusiness\n)\n\ntype DomainErrorType struct {\n    Type     ErrorType\n    Category ErrorCategory\n    Retryable bool\n}\n\nvar errorTypeRegistry = map[ErrorType]DomainErrorType{\n    ErrorTypeValidation: {\n        Category: CategoryValidation,\n        Retryable: false,\n    },\n    ErrorTypeDatabase: {\n        Category: CategoryInfrastructure,\n        Retryable: true,\n    },\n    ErrorTypePayment: {\n        Category: CategoryBusiness,\n        Retryable: true,\n    },\n}\n</code></pre>"},{"location":"advanced/formatting/","title":"Error Formatting","text":"<p>Error formatting in ewrap provides flexible ways to present errors in different formats and contexts. This capability is crucial for logging, debugging, API responses, and system integration. Let's explore how to effectively format errors to meet various needs in your application.</p>"},{"location":"advanced/formatting/#understanding-error-formatting","title":"Understanding Error Formatting","text":"<p>When an error occurs in your system, you might need to present it in different ways depending on the context:</p> <ul> <li>As JSON for API responses</li> <li>As YAML for configuration-related errors</li> <li>As structured text for logging</li> <li>As user-friendly messages for end users</li> </ul> <p>ewrap provides formatting options to handle all these cases while maintaining the rich context and metadata associated with your errors.</p>"},{"location":"advanced/formatting/#json-formatting","title":"JSON Formatting","text":"<p>JSON formatting is particularly useful for API responses and structured logging. Here's how to work with JSON formatting in ewrap:</p> <pre><code>func handleAPIError(w http.ResponseWriter, err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Convert error to JSON with full context\n        jsonOutput, err := wrappedErr.ToJSON(\n            ewrap.WithTimestampFormat(time.RFC3339),\n            ewrap.WithStackTrace(true),\n        )\n\n        if err != nil {\n            // Handle formatting error\n            http.Error(w, \"Internal Server Error\", http.StatusInternalServerError)\n            return\n        }\n\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusInternalServerError)\n        w.Write([]byte(jsonOutput))\n    }\n}\n</code></pre> <p>The resulting JSON might look like this:</p> <pre><code>{\n    \"message\": \"failed to process user order\",\n    \"timestamp\": \"2024-03-15T14:30:00Z\",\n    \"type\": \"database\",\n    \"severity\": \"error\",\n    \"stack\": \"main.processOrder:/app/main.go:42\\nmain.handleRequest:/app/main.go:28\",\n    \"metadata\": {\n        \"user_id\": \"12345\",\n        \"order_id\": \"ORD-789\",\n        \"attempt\": 1\n    },\n    \"cause\": {\n        \"message\": \"database connection timeout\",\n        \"type\": \"database\",\n        \"severity\": \"critical\"\n    }\n}\n</code></pre>"},{"location":"advanced/formatting/#yaml-formatting","title":"YAML Formatting","text":"<p>YAML formatting can be particularly useful for configuration-related errors or when you need a more human-readable format:</p> <pre><code>func logConfigurationError(err error, logger Logger) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Convert error to YAML for logging\n        yamlOutput, err := wrappedErr.ToYAML(\n            ewrap.WithStackTrace(true),\n        )\n\n        if err != nil {\n            logger.Error(\"failed to format error\", \"error\", err)\n            return\n        }\n\n        logger.Error(\"configuration error occurred\", \"details\", yamlOutput)\n    }\n}\n</code></pre> <p>The formatted YAML might look like this:</p> <pre><code>message: failed to load configuration\ntimestamp: 2024-03-15T14:30:00Z\ntype: configuration\nseverity: critical\nstack: |\n    main.loadConfig:/app/config.go:25\n    main.initialize:/app/main.go:15\nmetadata:\n    config_file: /etc/myapp/config.yaml\n    invalid_fields:\n        - database.host\n        - database.port\ncause:\n    message: invalid port number\n    type: validation\n</code></pre>"},{"location":"advanced/formatting/#custom-formatting","title":"Custom Formatting","text":"<p>Sometimes you need to create custom formats for specific use cases. Here's how to build custom formatters:</p> <pre><code>type ErrorFormatter struct {\n    TimestampFormat string\n    IncludeStack    bool\n    IncludeMetadata bool\n    MaxStackDepth   int\n}\n\nfunc NewErrorFormatter() *ErrorFormatter {\n    return &amp;ErrorFormatter{\n        TimestampFormat: time.RFC3339,\n        IncludeStack:    true,\n        IncludeMetadata: true,\n        MaxStackDepth:   10,\n    }\n}\n\nfunc (f *ErrorFormatter) Format(err *ewrap.Error) map[string]interface{} {\n    // Create base error information\n    formatted := map[string]interface{}{\n        \"message\":   err.Error(),\n        \"timestamp\": time.Now().Format(f.TimestampFormat),\n    }\n\n    // Add stack trace if enabled\n    if f.IncludeStack {\n        formatted[\"stack\"] = f.formatStack(err.Stack())\n    }\n\n    // Add metadata if enabled\n    if f.IncludeMetadata {\n        metadata := make(map[string]interface{})\n        // Extract and format metadata...\n        formatted[\"metadata\"] = metadata\n    }\n\n    return formatted\n}\n\nfunc (f *ErrorFormatter) formatStack(stack string) []string {\n    lines := strings.Split(stack, \"\\n\")\n    if len(lines) &gt; f.MaxStackDepth {\n        lines = lines[:f.MaxStackDepth]\n    }\n    return lines\n}\n</code></pre>"},{"location":"advanced/formatting/#user-friendly-error-messages","title":"User-Friendly Error Messages","text":"<p>When presenting errors to end users, you often need to transform technical errors into user-friendly messages while preserving the technical details for logging:</p> <pre><code>type UserErrorFormatter struct {\n    translations map[ErrorType]string\n    logger       Logger\n}\n\nfunc NewUserErrorFormatter(logger Logger) *UserErrorFormatter {\n    return &amp;UserErrorFormatter{\n        translations: map[ErrorType]string{\n            ErrorTypeValidation:    \"The provided information is invalid\",\n            ErrorTypeNotFound:      \"The requested resource could not be found\",\n            ErrorTypePermission:    \"You don't have permission to perform this action\",\n            ErrorTypeDatabase:      \"A system error occurred\",\n            ErrorTypeNetwork:       \"Connection issues detected\",\n            ErrorTypeConfiguration: \"System configuration error\",\n        },\n        logger: logger,\n    }\n}\n\nfunc (f *UserErrorFormatter) FormatForUser(err error) string {\n    // Always log the full technical error\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        f.logger.Error(\"error occurred\",\n            \"technical_details\", wrappedErr.ToJSON())\n\n        // Get error context\n        ctx := getErrorContext(wrappedErr)\n\n        // Return translated message\n        if msg, ok := f.translations[ctx.Type]; ok {\n            return msg\n        }\n    }\n\n    // Default message for unknown errors\n    return \"An unexpected error occurred\"\n}\n</code></pre>"},{"location":"advanced/formatting/#best-practices-for-error-formatting","title":"Best Practices for Error Formatting","text":""},{"location":"advanced/formatting/#1-security-conscious-formatting","title":"1. Security-Conscious Formatting","text":"<p>Be careful about what information you expose in different contexts:</p> <pre><code>func formatErrorResponse(err error, internal bool) interface{} {\n    wrappedErr, ok := err.(*ewrap.Error)\n    if !ok {\n        return map[string]string{\"message\": \"Internal Server Error\"}\n    }\n\n    if internal {\n        // Full details for internal logging\n        return map[string]interface{}{\n            \"message\":   wrappedErr.Error(),\n            \"stack\":     wrappedErr.Stack(),\n            \"metadata\":  wrappedErr.GetAllMetadata(),\n            \"type\":      getErrorContext(wrappedErr).Type,\n            \"severity\": getErrorContext(wrappedErr).Severity,\n        }\n    }\n\n    // Limited information for external responses\n    return map[string]string{\n        \"message\": sanitizeErrorMessage(wrappedErr.Error()),\n        \"code\":    getPublicErrorCode(wrappedErr),\n    }\n}\n</code></pre>"},{"location":"advanced/formatting/#2-consistent-format-structure","title":"2. Consistent Format Structure","text":"<p>Maintain consistent error format structures across your application:</p> <pre><code>type StandardErrorResponse struct {\n    Message   string                 `json:\"message\"`\n    Code      string                 `json:\"code\"`\n    Details   map[string]interface{} `json:\"details,omitempty\"`\n    RequestID string                 `json:\"request_id,omitempty\"`\n    Timestamp string                 `json:\"timestamp\"`\n}\n\nfunc NewStandardErrorResponse(err error, requestID string) StandardErrorResponse {\n    return StandardErrorResponse{\n        Message:   getErrorMessage(err),\n        Code:      getErrorCode(err),\n        Details:   getErrorDetails(err),\n        RequestID: requestID,\n        Timestamp: time.Now().UTC().Format(time.RFC3339),\n    }\n}\n</code></pre>"},{"location":"advanced/formatting/#3-context-aware-formatting","title":"3. Context-Aware Formatting","text":"<p>Adjust formatting based on the execution context:</p> <pre><code>func formatErrorByEnvironment(err error, env string) interface{} {\n    switch env {\n    case \"development\":\n        // Include everything in development\n        return formatWithFullDetails(err)\n    case \"testing\":\n        // Include stack traces but sanitize sensitive data\n        return formatForTesting(err)\n    case \"production\":\n        // Minimal public information\n        return formatForProduction(err)\n    default:\n        return formatWithDefaultSettings(err)\n    }\n}\n</code></pre>"},{"location":"advanced/performance/","title":"Performance Optimization","text":"<p>Understanding how to optimize error handling is crucial for maintaining high-performance applications. While error handling is essential, it shouldn't become a bottleneck in your application. Let's explore how ewrap helps you achieve efficient error handling and learn about optimization strategies.</p>"},{"location":"advanced/performance/#understanding-error-handling-performance","title":"Understanding Error Handling Performance","text":"<p>When we talk about performance in error handling, we need to consider several aspects:</p> <ol> <li>Memory allocation and garbage collection impact</li> <li>CPU overhead from stack trace capture</li> <li>Concurrency and contention in high-throughput scenarios</li> <li>The cost of error formatting and logging</li> <li>The impact of error wrapping chains</li> </ol> <p>Let's explore how ewrap addresses each of these concerns and how you can optimize your error handling.</p>"},{"location":"advanced/performance/#memory-management","title":"Memory Management","text":"<p>One of the most significant performance impacts in error handling comes from memory allocations. ewrap uses several strategies to minimize this impact:</p>"},{"location":"advanced/performance/#object-pooling","title":"Object Pooling","text":"<p>The Error Group pool is a prime example of how we can reduce memory pressure:</p> <pre><code>// Create a pool with an appropriate size for your use case\npool := ewrap.NewErrorGroupPool(4)\n\nfunc processItems(items []Item) error {\n    // Get an error group from the pool\n    eg := pool.Get()\n    defer eg.Release()  // Return to pool when done\n\n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            eg.Add(err)\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre> <p>This approach is particularly effective because:</p> <ol> <li>It reduces garbage collection pressure</li> <li>It minimizes memory fragmentation</li> <li>It provides predictable memory usage patterns</li> </ol>"},{"location":"advanced/performance/#pre-allocation-strategies","title":"Pre-allocation Strategies","text":"<p>When dealing with metadata or formatting, pre-allocation can significantly improve performance:</p> <pre><code>// Pre-allocate slices with expected capacity\nfunc buildErrorContext(err error, expectedFields int) map[string]interface{} {\n    // Allocate map with expected size to avoid resizing\n    context := make(map[string]interface{}, expectedFields)\n\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Pre-allocate string builder with reasonable capacity\n        var builder strings.Builder\n        builder.Grow(256)  // Reserve space for typical error message\n\n        // Build context efficiently\n        builder.WriteString(\"Error occurred in \")\n        builder.WriteString(wrappedErr.Operation())\n        context[\"message\"] = builder.String()\n\n        // Add other fields...\n    }\n\n    return context\n}\n</code></pre>"},{"location":"advanced/performance/#stack-trace-optimization","title":"Stack Trace Optimization","text":"<p>Stack traces are expensive to capture, so ewrap implements several optimizations:</p>"},{"location":"advanced/performance/#lazy-stack-capture","title":"Lazy Stack Capture","text":"<pre><code>type lazyStack struct {\n    pcs    []uintptr\n    frames runtime.Frames\n    once   sync.Once\n}\n\nfunc (ls *lazyStack) Frames() runtime.Frames {\n    ls.once.Do(func() {\n        if ls.frames == nil {\n            ls.frames = runtime.CallersFrames(ls.pcs)\n        }\n    })\n    return ls.frames\n}\n</code></pre>"},{"location":"advanced/performance/#stack-filtering","title":"Stack Filtering","text":"<p>We filter out unnecessary frames to reduce memory usage and improve readability:</p> <pre><code>func filterStack(stack []runtime.Frame) []runtime.Frame {\n    filtered := make([]runtime.Frame, 0, len(stack))\n    for _, frame := range stack {\n        if shouldIncludeFrame(frame) {\n            filtered = append(filtered, frame)\n        }\n    }\n    return filtered\n}\n\nfunc shouldIncludeFrame(frame runtime.Frame) bool {\n    // Skip runtime frames\n    if strings.Contains(frame.File, \"runtime/\") {\n        return false\n    }\n    // Skip ewrap internal frames\n    if strings.Contains(frame.File, \"ewrap/errors.go\") {\n        return false\n    }\n    return true\n}\n</code></pre>"},{"location":"advanced/performance/#concurrency-optimization","title":"Concurrency Optimization","text":"<p>In high-concurrency scenarios, efficient error handling becomes even more critical:</p>"},{"location":"advanced/performance/#lock-free-operations","title":"Lock-Free Operations","text":"<p>Where possible, ewrap uses atomic operations instead of locks:</p> <pre><code>type AtomicCounter struct {\n    value int64\n}\n\nfunc (c *AtomicCounter) Increment() {\n    atomic.AddInt64(&amp;c.value, 1)\n}\n\nfunc (c *AtomicCounter) Get() int64 {\n    return atomic.LoadInt64(&amp;c.value)\n}\n</code></pre>"},{"location":"advanced/performance/#minimizing-lock-contention","title":"Minimizing Lock Contention","text":"<p>When locks are necessary, we minimize their scope:</p> <pre><code>func (eg *ErrorGroup) Add(err error) {\n    if err == nil {\n        return\n    }\n\n    // Prepare the error outside the lock\n    wrappedErr := prepareError(err)\n\n    // Minimize critical section\n    eg.mu.Lock()\n    eg.errors = append(eg.errors, wrappedErr)\n    eg.mu.Unlock()\n}\n</code></pre>"},{"location":"advanced/performance/#formatting-performance","title":"Formatting Performance","text":"<p>Error formatting can be expensive, especially for JSON/YAML conversion. Here's how to optimize it:</p>"},{"location":"advanced/performance/#cached-formatting","title":"Cached Formatting","text":"<p>For frequently accessed formats:</p> <pre><code>type CachedError struct {\n    err          *ewrap.Error\n    jsonCache    atomic.Value\n    yamlCache    atomic.Value\n    cacheTimeout time.Duration\n}\n\nfunc (ce *CachedError) ToJSON() (string, error) {\n    if cached := ce.jsonCache.Load(); cached != nil {\n        cacheEntry := cached.(*formatCacheEntry)\n        if !cacheEntry.isExpired() {\n            return cacheEntry.data, nil\n        }\n    }\n\n    // Format and cache the result\n    json, err := ce.err.ToJSON()\n    if err != nil {\n        return \"\", err\n    }\n\n    ce.jsonCache.Store(&amp;formatCacheEntry{\n        data:    json,\n        expires: time.Now().Add(ce.cacheTimeout),\n    })\n\n    return json, nil\n}\n</code></pre>"},{"location":"advanced/performance/#efficient-buffer-usage","title":"Efficient Buffer Usage","text":"<p>When formatting errors:</p> <pre><code>// Pool of buffers for formatting\nvar bufferPool = sync.Pool{\n    New: func() interface{} {\n        return new(bytes.Buffer)\n    },\n}\n\nfunc formatError(err *ewrap.Error) string {\n    buf := bufferPool.Get().(*bytes.Buffer)\n    defer func() {\n        buf.Reset()\n        bufferPool.Put(buf)\n    }()\n\n    // Use buffer for formatting\n    buf.WriteString(\"Error: \")\n    buf.WriteString(err.Error())\n    buf.WriteString(\"\\nStack:\\n\")\n    buf.WriteString(err.Stack())\n\n    return buf.String()\n}\n</code></pre>"},{"location":"advanced/performance/#performance-monitoring","title":"Performance Monitoring","text":"<p>To ensure your error handling remains efficient, implement monitoring:</p> <pre><code>type ErrorMetrics struct {\n    creationTime   metrics.Histogram\n    wrappingTime   metrics.Histogram\n    stackDepth     metrics.Histogram\n    allocationSize metrics.Histogram\n}\n\nfunc TrackErrorMetrics(err error, metrics *ErrorMetrics) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        metrics.stackDepth.Observe(float64(len(wrappedErr.Stack())))\n        // Track other metrics...\n    }\n}\n</code></pre>"},{"location":"advanced/performance/#best-practices-for-performance","title":"Best Practices for Performance","text":""},{"location":"advanced/performance/#1-pool-appropriately","title":"1. Pool Appropriately","text":"<p>Choose pool sizes based on your application's characteristics:</p> <pre><code>func initializePools(config Config) {\n    // Size pools based on expected concurrent operations\n    errorGroupPool := ewrap.NewErrorGroupPool(config.MaxConcurrentOperations)\n\n    // Size buffer pools based on expected error volume\n    bufferPool := sync.Pool{\n        New: func() interface{} {\n            return bytes.NewBuffer(make([]byte, 0, config.AverageErrorSize))\n        },\n    }\n}\n</code></pre>"},{"location":"advanced/performance/#2-minimize-allocations","title":"2. Minimize Allocations","text":"<p>Be mindful of unnecessary allocations:</p> <pre><code>// Good - reuse error types for common cases\nvar (\n    ErrNotFound = ewrap.New(\"resource not found\",\n        ewrap.WithErrorType(ErrorTypeNotFound))\n    ErrUnauthorized = ewrap.New(\"unauthorized access\",\n        ewrap.WithErrorType(ErrorTypePermission))\n)\n\n// Avoid - creating new errors for common cases\nif !exists {\n    return ewrap.New(\"resource not found\")  // Creates new error each time\n}\n</code></pre>"},{"location":"advanced/performance/#3-profile-and-monitor","title":"3. Profile and Monitor","text":"<p>Regularly profile your error handling:</p> <pre><code>func TestErrorPerformance(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"skipping performance test in short mode\")\n    }\n\n    // Profile creation\n    b.Run(\"ErrorCreation\", func(b *testing.B) {\n        b.ResetTimer()\n        for i := 0; i &lt; b.N; i++ {\n            _ = ewrap.New(\"test error\")\n        }\n    })\n\n    // Profile wrapping\n    b.Run(\"ErrorWrapping\", func(b *testing.B) {\n        baseErr := errors.New(\"base error\")\n        b.ResetTimer()\n        for i := 0; i &lt; b.N; i++ {\n            _ = ewrap.Wrap(baseErr, \"wrapped error\")\n        }\n    })\n}\n</code></pre>"},{"location":"advanced/testing/","title":"Testing Error Handling","text":"<p>Testing error handling is crucial for building reliable applications. Good error handling tests not only verify that errors are caught and handled correctly but also ensure that error contexts, metadata, and performance characteristics meet your requirements. Let's explore how to effectively test error handling using ewrap.</p>"},{"location":"advanced/testing/#understanding-error-testing","title":"Understanding Error Testing","text":"<p>Testing error handling requires a different mindset from testing normal application flow. We need to verify not just that errors are caught, but that they carry the right information, perform efficiently, and integrate properly with the rest of our system. Let's break this down into manageable pieces.</p>"},{"location":"advanced/testing/#unit-testing-error-handling","title":"Unit Testing Error Handling","text":"<p>Let's start with basic unit tests that verify error creation and handling:</p> <pre><code>func TestErrorCreation(t *testing.T) {\n    // We'll create a structured test to verify different aspects of error creation\n    testCases := []struct {\n        name           string\n        message        string\n        errorType     ErrorType\n        severity      Severity\n        metadata      map[string]interface{}\n        expectedStack bool\n    }{\n        {\n            name:       \"Basic Error\",\n            message:    \"something went wrong\",\n            errorType:  ErrorTypeUnknown,\n            severity:   SeverityError,\n            metadata:   nil,\n            expectedStack: true,\n        },\n        {\n            name:       \"Database Error with Metadata\",\n            message:    \"connection failed\",\n            errorType:  ErrorTypeDatabase,\n            severity:   SeverityCritical,\n            metadata: map[string]interface{}{\n                \"host\": \"localhost\",\n                \"port\": 5432,\n            },\n            expectedStack: true,\n        },\n    }\n\n    for _, tc := range testCases {\n        t.Run(tc.name, func(t *testing.T) {\n            // Create the error with test case parameters\n            err := ewrap.New(tc.message,\n                ewrap.WithContext(context.Background(), tc.errorType, tc.severity))\n\n            // Add metadata if provided\n            if tc.metadata != nil {\n                for k, v := range tc.metadata {\n                    err = err.WithMetadata(k, v)\n                }\n            }\n\n            // Verify error properties\n            if err.Error() != tc.message {\n                t.Errorf(\"Expected message %q, got %q\", tc.message, err.Error())\n            }\n\n            // Verify stack trace presence\n            if tc.expectedStack &amp;&amp; err.Stack() == \"\" {\n                t.Error(\"Expected stack trace, but none was captured\")\n            }\n\n            // Verify metadata\n            if tc.metadata != nil {\n                for k, v := range tc.metadata {\n                    if mv, ok := err.GetMetadata(k); !ok || mv != v {\n                        t.Errorf(\"Metadata %q: expected %v, got %v\", k, v, mv)\n                    }\n                }\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"advanced/testing/#testing-error-wrapping","title":"Testing Error Wrapping","text":"<p>Error wrapping requires special attention to ensure context is preserved:</p> <pre><code>func TestErrorWrapping(t *testing.T) {\n    // Create a mock logger to verify logging behavior\n    mockLogger := NewMockLogger(t)\n\n    // Create a base error\n    baseErr := errors.New(\"base error\")\n\n    // Create our wrapped error\n    wrappedErr := ewrap.Wrap(baseErr, \"operation failed\",\n        ewrap.WithLogger(mockLogger),\n        ewrap.WithContext(context.Background(), ErrorTypeDatabase, SeverityCritical))\n\n    // Test error chain\n    t.Run(\"Error Chain\", func(t *testing.T) {\n        // Verify the complete error message\n        expectedMsg := \"operation failed: base error\"\n        if wrappedErr.Error() != expectedMsg {\n            t.Errorf(\"Expected message %q, got %q\", expectedMsg, wrappedErr.Error())\n        }\n\n        // Verify we can unwrap to the original error\n        if !errors.Is(wrappedErr, baseErr) {\n            t.Error(\"Wrapped error should match the original error\")\n        }\n\n        // Verify the error chain is preserved\n        cause := wrappedErr.Unwrap()\n        if cause != baseErr {\n            t.Error(\"Unwrapped error should be the base error\")\n        }\n    })\n\n    // Test context preservation\n    t.Run(\"Context Preservation\", func(t *testing.T) {\n        ctx := getErrorContext(wrappedErr)\n\n        if ctx.Type != ErrorTypeDatabase {\n            t.Errorf(\"Expected error type %v, got %v\", ErrorTypeDatabase, ctx.Type)\n        }\n\n        if ctx.Severity != SeverityCritical {\n            t.Errorf(\"Expected severity %v, got %v\", SeverityCritical, ctx.Severity)\n        }\n    })\n}\n</code></pre>"},{"location":"advanced/testing/#testing-error-groups","title":"Testing Error Groups","text":"<p>Error groups require testing both individual operations and concurrent behavior:</p> <pre><code>func TestErrorGroup(t *testing.T) {\n    // Test pool creation and basic operations\n    t.Run(\"Basic Operations\", func(t *testing.T) {\n        pool := ewrap.NewErrorGroupPool(4)\n        eg := pool.Get()\n        defer eg.Release()\n\n        // Add some errors\n        eg.Add(ewrap.New(\"error 1\"))\n        eg.Add(ewrap.New(\"error 2\"))\n\n        // Verify error count\n        if !eg.HasErrors() {\n            t.Error(\"Expected errors in group\")\n        }\n\n        // Verify error message format\n        errMsg := eg.Error()\n        if !strings.Contains(errMsg, \"error 1\") || !strings.Contains(errMsg, \"error 2\") {\n            t.Error(\"Error message doesn't contain all errors\")\n        }\n    })\n\n    // Test concurrent operations\n    t.Run(\"Concurrent Operations\", func(t *testing.T) {\n        pool := ewrap.NewErrorGroupPool(4)\n        eg := pool.Get()\n        defer eg.Release()\n\n        var wg sync.WaitGroup\n        for i := 0; i &lt; 100; i++ {\n            wg.Add(1)\n            go func(i int) {\n                defer wg.Done()\n                eg.Add(ewrap.New(fmt.Sprintf(\"concurrent error %d\", i)))\n            }(i)\n        }\n\n        wg.Wait()\n\n        // Verify all errors were captured\n        errs := eg.Errors()\n        if len(errs) != 100 {\n            t.Errorf(\"Expected 100 errors, got %d\", len(errs))\n        }\n    })\n}\n</code></pre>"},{"location":"advanced/testing/#testing-circuit-breakers","title":"Testing Circuit Breakers","text":"<p>Circuit breakers require testing state transitions and timing behavior:</p> <pre><code>func TestCircuitBreaker(t *testing.T) {\n    t.Run(\"State Transitions\", func(t *testing.T) {\n        cb := ewrap.NewCircuitBreaker(\"test\", 3, time.Second)\n\n        // Should start closed\n        if !cb.CanExecute() {\n            t.Error(\"Circuit breaker should start in closed state\")\n        }\n\n        // Record failures until open\n        for i := 0; i &lt; 3; i++ {\n            cb.RecordFailure()\n        }\n\n        // Should now be open\n        if cb.CanExecute() {\n            t.Error(\"Circuit breaker should be open after failures\")\n        }\n\n        // Wait for timeout\n        time.Sleep(time.Second + 100*time.Millisecond)\n\n        // Should be half-open\n        if !cb.CanExecute() {\n            t.Error(\"Circuit breaker should be half-open after timeout\")\n        }\n\n        // Record success to close\n        cb.RecordSuccess()\n\n        // Should be closed\n        if !cb.CanExecute() {\n            t.Error(\"Circuit breaker should be closed after success\")\n        }\n    })\n}\n</code></pre>"},{"location":"advanced/testing/#performance-testing","title":"Performance Testing","text":"<p>Performance testing is crucial for error handling code:</p> <pre><code>func BenchmarkErrorOperations(b *testing.B) {\n    // Benchmark error creation\n    b.Run(\"Creation\", func(b *testing.B) {\n        b.ReportAllocs()\n        for i := 0; i &lt; b.N; i++ {\n            _ = ewrap.New(\"test error\")\n        }\n    })\n\n    // Benchmark error wrapping\n    b.Run(\"Wrapping\", func(b *testing.B) {\n        baseErr := errors.New(\"base error\")\n        b.ReportAllocs()\n        for i := 0; i &lt; b.N; i++ {\n            _ = ewrap.Wrap(baseErr, \"wrapped error\")\n        }\n    })\n\n    // Benchmark error group operations\n    b.Run(\"ErrorGroup\", func(b *testing.B) {\n        pool := ewrap.NewErrorGroupPool(4)\n        b.ReportAllocs()\n        b.RunParallel(func(pb *testing.PB) {\n            for pb.Next() {\n                eg := pool.Get()\n                eg.Add(errors.New(\"test error\"))\n                _ = eg.Error()\n                eg.Release()\n            }\n        })\n    })\n}\n</code></pre>"},{"location":"advanced/testing/#integration-testing","title":"Integration Testing","text":"<p>Testing error handling in integration scenarios:</p> <pre><code>func TestErrorIntegration(t *testing.T) {\n    // Create a test server\n    srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        // Simulate error handling in an HTTP server\n        err := processRequest(r)\n        if err != nil {\n            // Convert error to API response\n            resp := formatErrorResponse(err)\n            w.WriteHeader(http.StatusInternalServerError)\n            json.NewEncoder(w).Encode(resp)\n            return\n        }\n        w.WriteHeader(http.StatusOK)\n    }))\n    defer srv.Close()\n\n    // Test error handling through the entire stack\n    t.Run(\"Integration\", func(t *testing.T) {\n        resp, err := http.Get(srv.URL)\n        if err != nil {\n            t.Fatal(err)\n        }\n        defer resp.Body.Close()\n\n        // Verify error response format\n        if resp.StatusCode != http.StatusInternalServerError {\n            t.Errorf(\"Expected status 500, got %d\", resp.StatusCode)\n        }\n\n        var errorResp map[string]interface{}\n        if err := json.NewDecoder(resp.Body).Decode(&amp;errorResp); err != nil {\n            t.Fatal(err)\n        }\n\n        // Verify error response structure\n        requiredFields := []string{\"message\", \"code\", \"timestamp\"}\n        for _, field := range requiredFields {\n            if _, ok := errorResp[field]; !ok {\n                t.Errorf(\"Missing required field: %s\", field)\n            }\n        }\n    })\n}\n</code></pre>"},{"location":"api/error-types/","title":"Error Types and Severity","text":"<p>Understanding error types and severity levels is fundamental to using ewrap effectively. This guide explains the built-in error categorization system and how to leverage it for better error handling.</p>"},{"location":"api/error-types/#error-types-explained","title":"Error Types Explained","text":"<p>Error types in ewrap are more than just labels - they represent distinct categories of failures that can occur in your application. Each type suggests different handling strategies and helps maintain consistency in how errors are processed throughout your system.</p>"},{"location":"api/error-types/#built-in-error-types","title":"Built-in Error Types","text":"<pre><code>const (\n    ErrorTypeUnknown ErrorType = iota\n    ErrorTypeValidation\n    ErrorTypeNotFound\n    ErrorTypePermission\n    ErrorTypeDatabase\n    ErrorTypeNetwork\n    ErrorTypeConfiguration\n    ErrorTypeInternal\n    ErrorTypeExternal\n)\n</code></pre> <p>Let's explore each error type and its intended use:</p>"},{"location":"api/error-types/#errortypeunknown","title":"ErrorTypeUnknown","text":"<p>Used when an error doesn't clearly fit into other categories. While it's available as a fallback, you should try to use more specific error types when possible.</p> <pre><code>err := ewrap.New(\"unexpected error occurred\",\n    ewrap.WithContext(ctx, ErrorTypeUnknown, SeverityError))\n</code></pre>"},{"location":"api/error-types/#errortypevalidation","title":"ErrorTypeValidation","text":"<p>For errors related to input validation, data formatting, or business rule violations. These errors typically indicate that the request or data being processed doesn't meet required criteria.</p> <pre><code>func validateUser(user User) error {\n    if user.Age &lt; 18 {\n        return ewrap.New(\"user must be 18 or older\",\n            ewrap.WithContext(ctx, ErrorTypeValidation, SeverityError)).\n            WithMetadata(\"provided_age\", user.Age).\n            WithMetadata(\"minimum_age\", 18)\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypenotfound","title":"ErrorTypeNotFound","text":"<p>Indicates that a requested resource doesn't exist. This is particularly useful in API endpoints and database operations.</p> <pre><code>func getUser(ctx context.Context, userID string) (*User, error) {\n    user, err := db.FindUser(userID)\n    if err == sql.ErrNoRows {\n        return nil, ewrap.New(\"user not found\",\n            ewrap.WithContext(ctx, ErrorTypeNotFound, SeverityWarning)).\n            WithMetadata(\"user_id\", userID)\n    }\n    return user, err\n}\n</code></pre>"},{"location":"api/error-types/#errortypepermission","title":"ErrorTypePermission","text":"<p>For authorization and authentication failures. These errors indicate that the operation failed due to insufficient permissions or invalid credentials.</p> <pre><code>func validateAccess(ctx context.Context, userID string, resource string) error {\n    if !hasPermission(userID, resource) {\n        return ewrap.New(\"access denied\",\n            ewrap.WithContext(ctx, ErrorTypePermission, SeverityWarning)).\n            WithMetadata(\"user_id\", userID).\n            WithMetadata(\"resource\", resource).\n            WithMetadata(\"required_role\", \"admin\")\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypedatabase","title":"ErrorTypeDatabase","text":"<p>Used for database-related errors, including connection issues, query failures, and transaction problems.</p> <pre><code>func saveUserData(ctx context.Context, user User) error {\n    if err := db.Insert(user); err != nil {\n        return ewrap.Wrap(err, \"failed to save user data\",\n            ewrap.WithContext(ctx, ErrorTypeDatabase, SeverityCritical)).\n            WithMetadata(\"table\", \"users\").\n            WithMetadata(\"operation\", \"insert\")\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypenetwork","title":"ErrorTypeNetwork","text":"<p>For network-related failures, including API calls, service communication, and connectivity issues.</p> <pre><code>func callExternalAPI(ctx context.Context, endpoint string) error {\n    resp, err := http.Get(endpoint)\n    if err != nil {\n        return ewrap.Wrap(err, \"API call failed\",\n            ewrap.WithContext(ctx, ErrorTypeNetwork, SeverityError)).\n            WithMetadata(\"endpoint\", endpoint).\n            WithMetadata(\"timeout_seconds\", 30)\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypeconfiguration","title":"ErrorTypeConfiguration","text":"<p>Used when errors occur due to misconfiguration or invalid settings.</p> <pre><code>func loadConfig(ctx context.Context, path string) (*Config, error) {\n    cfg, err := parseConfig(path)\n    if err != nil {\n        return nil, ewrap.Wrap(err, \"invalid configuration\",\n            ewrap.WithContext(ctx, ErrorTypeConfiguration, SeverityCritical)).\n            WithMetadata(\"config_path\", path).\n            WithMetadata(\"invalid_fields\", getInvalidFields(err))\n    }\n    return cfg, nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypeinternal","title":"ErrorTypeInternal","text":"<p>For internal system errors that aren't caused by external factors or user input.</p> <pre><code>func processData(ctx context.Context, data []byte) error {\n    if err := internalProcess(data); err != nil {\n        return ewrap.Wrap(err, \"internal processing failed\",\n            ewrap.WithContext(ctx, ErrorTypeInternal, SeverityCritical)).\n            WithMetadata(\"process_id\", getCurrentProcessID()).\n            WithMetadata(\"memory_usage\", getMemoryUsage())\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#errortypeexternal","title":"ErrorTypeExternal","text":"<p>For errors originating from external services or systems.</p> <pre><code>func callPaymentProvider(ctx context.Context, payment Payment) error {\n    result, err := paymentProvider.Process(payment)\n    if err != nil {\n        return ewrap.Wrap(err, \"payment processing failed\",\n            ewrap.WithContext(ctx, ErrorTypeExternal, SeverityCritical)).\n            WithMetadata(\"provider\", \"stripe\").\n            WithMetadata(\"payment_id\", payment.ID).\n            WithMetadata(\"status_code\", result.StatusCode)\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#severity-levels","title":"Severity Levels","text":"<p>Severity levels help indicate the impact and urgency of an error. ewrap provides four severity levels:</p> <pre><code>const (\n    SeverityInfo Severity = iota\n    SeverityWarning\n    SeverityError\n    SeverityCritical\n)\n</code></pre>"},{"location":"api/error-types/#using-severity-levels-effectively","title":"Using Severity Levels Effectively","text":"<p>The choice of severity level should reflect the impact of the error on your system:</p>"},{"location":"api/error-types/#severityinfo","title":"SeverityInfo","text":"<p>For informational messages that don't indicate a problem but might be useful for debugging or monitoring.</p> <pre><code>func auditAction(ctx context.Context, action string) error {\n    return ewrap.New(\"action audited\",\n        ewrap.WithContext(ctx, ErrorTypeInternal, SeverityInfo)).\n        WithMetadata(\"action\", action).\n        WithMetadata(\"timestamp\", time.Now())\n}\n</code></pre>"},{"location":"api/error-types/#severitywarning","title":"SeverityWarning","text":"<p>For issues that don't prevent the system from functioning but require attention.</p> <pre><code>func checkDiskSpace(ctx context.Context) error {\n    if usage := getDiskUsage(); usage &gt; 80 {\n        return ewrap.New(\"high disk usage detected\",\n            ewrap.WithContext(ctx, ErrorTypeInternal, SeverityWarning)).\n            WithMetadata(\"usage_percentage\", usage).\n            WithMetadata(\"threshold\", 80)\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#severityerror","title":"SeverityError","text":"<p>For significant issues that prevent a specific operation from completing successfully.</p> <pre><code>func processOrder(ctx context.Context, order Order) error {\n    if err := validateOrder(order); err != nil {\n        return ewrap.Wrap(err, \"order validation failed\",\n            ewrap.WithContext(ctx, ErrorTypeValidation, SeverityError)).\n            WithMetadata(\"order_id\", order.ID)\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/error-types/#severitycritical","title":"SeverityCritical","text":"<p>For severe issues that might affect system stability or require immediate attention.</p> <pre><code>func initializeDatabase(ctx context.Context) error {\n    if err := db.Connect(); err != nil {\n        return ewrap.Wrap(err, \"database initialization failed\",\n            ewrap.WithContext(ctx, ErrorTypeDatabase, SeverityCritical)).\n            WithMetadata(\"retry_count\", 3).\n            WithMetadata(\"last_error\", err.Error())\n    }\n    return nil\n}\n</code></pre>"},{"location":"api/interfaces/","title":"Interfaces","text":"<p>The ewrap package is built around several key interfaces that provide flexibility and extensibility. Understanding these interfaces is crucial for effectively integrating ewrap into your application and extending its functionality to meet your specific needs.</p>"},{"location":"api/interfaces/#core-interfaces","title":"Core Interfaces","text":""},{"location":"api/interfaces/#logger-interface","title":"Logger Interface","text":"<p>The Logger interface is fundamental to ewrap's logging capabilities. It provides a standardized way to log error information at different severity levels:</p> <pre><code>type Logger interface {\n    Error(msg string, keysAndValues ...interface{})\n    Debug(msg string, keysAndValues ...interface{})\n    Info(msg string, keysAndValues ...interface{})\n}\n</code></pre> <p>This interface is intentionally simple yet powerful. Let's explore how to implement and use it effectively:</p> <pre><code>// Example implementation using standard log package\ntype StandardLogger struct {\n    logger *log.Logger\n}\n\nfunc (l *StandardLogger) Error(msg string, keysAndValues ...interface{}) {\n    l.logger.Printf(\"ERROR: %s %v\", msg, formatKeyValues(keysAndValues...))\n}\n\nfunc (l *StandardLogger) Debug(msg string, keysAndValues ...interface{}) {\n    l.logger.Printf(\"DEBUG: %s %v\", msg, formatKeyValues(keysAndValues...))\n}\n\nfunc (l *StandardLogger) Info(msg string, keysAndValues ...interface{}) {\n    l.logger.Printf(\"INFO: %s %v\", msg, formatKeyValues(keysAndValues...))\n}\n\n// Helper function to format key-value pairs\nfunc formatKeyValues(keysAndValues ...interface{}) string {\n    var pairs []string\n    for i := 0; i &lt; len(keysAndValues); i += 2 {\n        if i+1 &lt; len(keysAndValues) {\n            pairs = append(pairs, fmt.Sprintf(\"%v=%v\",\n                keysAndValues[i], keysAndValues[i+1]))\n        }\n    }\n    return strings.Join(pairs, \" \")\n}\n</code></pre> <p>The Logger interface is designed to:</p> <ul> <li>Support structured logging through key-value pairs</li> <li>Provide different log levels for appropriate error handling</li> <li>Be easily implemented by existing logging frameworks</li> <li>Allow for context-aware logging</li> </ul>"},{"location":"api/interfaces/#error-interface","title":"Error Interface","text":"<p>While ewrap's Error type implements Go's standard error interface, it extends it with additional capabilities:</p> <pre><code>type error interface {\n    Error() string\n}\n\n// ewrap.Error implements these additional methods:\ntype Error struct {\n    // Cause returns the underlying cause of the error\n    Cause() error\n\n    // Stack returns the error's stack trace\n    Stack() string\n\n    // GetMetadata retrieves metadata associated with the error\n    GetMetadata(key string) (interface{}, bool)\n\n    // WithMetadata adds metadata to the error\n    WithMetadata(key string, value interface{}) *Error\n\n    // Is reports whether target matches err in the error chain\n    Is(target error) bool\n\n    // Unwrap provides compatibility with Go 1.13 error chains\n    Unwrap() error\n}\n</code></pre> <p>Understanding these interfaces helps when working with errors:</p> <pre><code>func processError(err error) {\n    // Type assert to access ewrap.Error functionality\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Access stack trace\n        fmt.Printf(\"Stack Trace:\\n%s\\n\", wrappedErr.Stack())\n\n        // Access metadata\n        if requestID, ok := wrappedErr.GetMetadata(\"request_id\"); ok {\n            fmt.Printf(\"Request ID: %v\\n\", requestID)\n        }\n\n        // Access cause chain\n        for cause := wrappedErr; cause != nil; cause = cause.Unwrap() {\n            fmt.Printf(\"Error: %s\\n\", cause.Error())\n        }\n    }\n}\n</code></pre>"},{"location":"api/interfaces/#interface-integration","title":"Interface Integration","text":""},{"location":"api/interfaces/#implementing-custom-loggers","title":"Implementing Custom Loggers","text":"<p>Creating custom loggers for different environments or logging systems:</p> <pre><code>// Production logger with structured output\ntype ProductionLogger struct {\n    output io.Writer\n}\n\nfunc (l *ProductionLogger) Error(msg string, keysAndValues ...interface{}) {\n    entry := LogEntry{\n        Level:     \"ERROR\",\n        Message:   msg,\n        Timestamp: time.Now().UTC(),\n        Data:      makeMap(keysAndValues...),\n    }\n    json.NewEncoder(l.output).Encode(entry)\n}\n\n// Test logger for capturing logs in tests\ntype TestLogger struct {\n    Logs []LogEntry\n    mu   sync.Mutex\n}\n\nfunc (l *TestLogger) Error(msg string, keysAndValues ...interface{}) {\n    l.mu.Lock()\n    defer l.mu.Unlock()\n\n    l.Logs = append(l.Logs, LogEntry{\n        Level:     \"ERROR\",\n        Message:   msg,\n        Timestamp: time.Now(),\n        Data:      makeMap(keysAndValues...),\n    })\n}\n</code></pre>"},{"location":"api/interfaces/#interface-composition","title":"Interface Composition","text":"<p>Combining interfaces for enhanced functionality:</p> <pre><code>// MetricsLogger combines logging with metrics collection\ntype MetricsLogger struct {\n    logger  Logger\n    metrics MetricsCollector\n}\n\nfunc (l *MetricsLogger) Error(msg string, keysAndValues ...interface{}) {\n    // Log the error\n    l.logger.Error(msg, keysAndValues...)\n\n    // Collect metrics\n    l.metrics.IncrementCounter(\"errors_total\", 1)\n    l.metrics.Record(\"error_occurred\", keysAndValues...)\n}\n</code></pre>"},{"location":"api/interfaces/#best-practices","title":"Best Practices","text":""},{"location":"api/interfaces/#logger-implementation","title":"Logger Implementation","text":"<p>When implementing the Logger interface, consider these guidelines:</p> <pre><code>// Structured logger with configurable output\ntype StructuredLogger struct {\n    output    io.Writer\n    minLevel  LogLevel\n    formatter LogFormatter\n    mu        sync.Mutex\n}\n\nfunc (l *StructuredLogger) Error(msg string, keysAndValues ...interface{}) {\n    if l.minLevel &lt;= ErrorLevel {\n        l.log(ErrorLevel, msg, keysAndValues...)\n    }\n}\n\nfunc (l *StructuredLogger) log(level LogLevel, msg string, keysAndValues ...interface{}) {\n    l.mu.Lock()\n    defer l.mu.Unlock()\n\n    entry := l.formatter.Format(level, msg, keysAndValues...)\n    l.output.Write(entry)\n}\n</code></pre>"},{"location":"api/interfaces/#interface-testing","title":"Interface Testing","text":"<p>Writing tests for interface implementations:</p> <pre><code>func TestLogger(t *testing.T) {\n    // Create a buffer to capture log output\n    var buf bytes.Buffer\n    logger := NewStructuredLogger(&amp;buf)\n\n    // Test error logging\n    logger.Error(\"test error\",\n        \"key1\", \"value1\",\n        \"key2\", 42)\n\n    // Verify log output\n    output := buf.String()\n    if !strings.Contains(output, \"test error\") {\n        t.Error(\"Log message not found in output\")\n    }\n\n    // Verify structured data\n    var logEntry LogEntry\n    if err := json.NewDecoder(&amp;buf).Decode(&amp;logEntry); err != nil {\n        t.Fatal(err)\n    }\n\n    if logEntry.Level != \"ERROR\" {\n        t.Errorf(\"Expected level ERROR, got %s\", logEntry.Level)\n    }\n}\n</code></pre>"},{"location":"api/interfaces/#interface-extensions","title":"Interface Extensions","text":"<p>Creating specialized interfaces for specific use cases:</p> <pre><code>// ContextualLogger adds context awareness to the basic Logger interface\ntype ContextualLogger interface {\n    Logger\n    WithContext(ctx context.Context) Logger\n    WithFields(fields map[string]interface{}) Logger\n}\n\n// Implementation example\ntype contextualLogger struct {\n    Logger\n    ctx    context.Context\n    fields map[string]interface{}\n}\n\nfunc (l *contextualLogger) WithContext(ctx context.Context) Logger {\n    return &amp;contextualLogger{\n        Logger: l.Logger,\n        ctx:    ctx,\n        fields: l.fields,\n    }\n}\n\nfunc (l *contextualLogger) Error(msg string, keysAndValues ...interface{}) {\n    // Combine context values, fields, and provided key-values\n    allKeyValues := l.mergeContextAndFields(keysAndValues...)\n    l.Logger.Error(msg, allKeyValues...)\n}\n</code></pre>"},{"location":"api/options/","title":"Options","text":"<p>Options in ewrap provide a flexible way to configure error behavior. Using the functional options pattern, you can customize how errors are created, logged, and handled while maintaining clean and extensible code.</p>"},{"location":"api/options/#understanding-options","title":"Understanding Options","text":"<p>Options are functions that modify error behavior. They follow Go's functional options pattern, which allows for flexible and readable configuration. Each option function takes an error pointer and modifies its properties:</p> <pre><code>type Option func(*Error)\n</code></pre>"},{"location":"api/options/#built-in-options","title":"Built-in Options","text":""},{"location":"api/options/#withcontext","title":"WithContext","text":"<p>The <code>WithContext</code> option enriches errors with contextual information, including error type, severity, and relevant request data:</p> <pre><code>func processUser(ctx context.Context, userID string) error {\n    err := ewrap.New(\"user processing failed\",\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError))\n\n    // The error now includes:\n    // - Error type and severity\n    // - Stack trace location\n    // - Request ID (if present in context)\n    // - User information (if present in context)\n    // - Operation name (if present in context)\n    // - Component name (if present in context)\n    // - Environment information\n    return err\n}\n</code></pre> <p>The context option automatically extracts common values from the provided context:</p> <ul> <li><code>request_id</code> for request tracing</li> <li><code>user</code> for user identification</li> <li><code>operation</code> for operation naming</li> <li><code>component</code> for system component identification</li> </ul>"},{"location":"api/options/#withlogger","title":"WithLogger","text":"<p>The <code>WithLogger</code> option attaches a logger to the error, enabling automatic logging of error events:</p> <pre><code>// Create a logger (implementing the Logger interface)\nlogger := NewZapLogger()\n\n// Attach logger to error\nerr := ewrap.New(\"database connection failed\",\n    ewrap.WithLogger(logger),\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n\n// The error will automatically log:\n// - Error creation\n// - Context addition\n// - Metadata changes\n// - Stack trace information\n</code></pre>"},{"location":"api/options/#withretry","title":"WithRetry","text":"<p>The <code>WithRetry</code> option configures retry behavior for recoverable errors:</p> <pre><code>err := ewrap.New(\"temporary network failure\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNetwork, ewrap.SeverityError),\n    ewrap.WithRetry(3, time.Second*5))\n\n// The error now includes retry information:\n// - Maximum retry attempts (3)\n// - Delay between attempts (5 seconds)\n// - Retry strategy configuration\n</code></pre>"},{"location":"api/options/#combining-options","title":"Combining Options","text":"<p>Options can be combined to create rich error configurations:</p> <pre><code>func processOrder(ctx context.Context, orderID string) error {\n    // Create an error with multiple options\n    return ewrap.New(\"order processing failed\",\n        // Add context information\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError),\n        // Attach logger\n        ewrap.WithLogger(logger),\n        // Configure retry behavior\n        ewrap.WithRetry(3, time.Second*5))\n}\n</code></pre>"},{"location":"api/options/#creating-custom-options","title":"Creating Custom Options","text":"<p>You can create custom options to extend error functionality:</p> <pre><code>// WithCorrelationID adds a correlation ID to the error\nfunc WithCorrelationID(correlationID string) ewrap.Option {\n    return func(err *ewrap.Error) {\n        err.WithMetadata(\"correlation_id\", correlationID)\n    }\n}\n\n// WithResource adds resource information to the error\nfunc WithResource(resourceType, resourceID string) ewrap.Option {\n    return func(err *ewrap.Error) {\n        err.WithMetadata(\"resource_type\", resourceType)\n        err.WithMetadata(\"resource_id\", resourceID)\n    }\n}\n\n// Usage example\nerr := ewrap.New(\"resource access failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypePermission, ewrap.SeverityError),\n    WithCorrelationID(\"corr-123\"),\n    WithResource(\"document\", \"doc-456\"))\n</code></pre>"},{"location":"api/options/#best-practices","title":"Best Practices","text":""},{"location":"api/options/#option-organization","title":"Option Organization","text":"<p>Group related options together for better readability:</p> <pre><code>// Configuration options\nconfigOpts := []ewrap.Option{\n    ewrap.WithContext(ctx, errorType, severity),\n    ewrap.WithLogger(logger),\n}\n\n// Retry options\nretryOpts := []ewrap.Option{\n    ewrap.WithRetry(maxAttempts, delay),\n}\n\n// Combine all options\nallOpts := append(configOpts, retryOpts...)\n\n// Create error with combined options\nerr := ewrap.New(\"operation failed\", allOpts...)\n</code></pre>"},{"location":"api/options/#option-factories","title":"Option Factories","text":"<p>Create factory functions for commonly used option combinations:</p> <pre><code>// CreateHTTPErrorOptions creates standard options for HTTP handlers\nfunc CreateHTTPErrorOptions(ctx context.Context, logger Logger) []ewrap.Option {\n    return []ewrap.Option{\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError),\n        ewrap.WithLogger(logger),\n        WithCorrelationID(GetRequestID(ctx)),\n    }\n}\n\n// Usage in HTTP handlers\nfunc handleRequest(w http.ResponseWriter, r *http.Request) {\n    opts := CreateHTTPErrorOptions(r.Context(), logger)\n\n    if err := processRequest(r); err != nil {\n        err = ewrap.Wrap(err, \"request processing failed\", opts...)\n        handleError(w, err)\n        return\n    }\n}\n</code></pre>"},{"location":"api/options/#option-validation","title":"Option Validation","text":"<p>When creating custom options, include validation logic:</p> <pre><code>// WithTimeout adds a timeout duration to the error\nfunc WithTimeout(duration time.Duration) ewrap.Option {\n    return func(err *ewrap.Error) {\n        // Validate input\n        if duration &lt;= 0 {\n            duration = time.Second * 30 // Default timeout\n        }\n\n        err.WithMetadata(\"timeout\", duration.String())\n        err.WithMetadata(\"deadline\", time.Now().Add(duration))\n    }\n}\n</code></pre>"},{"location":"api/options/#dynamic-options","title":"Dynamic Options","text":"<p>Create options that adapt based on conditions:</p> <pre><code>// WithEnvironmentAwareLogging adjusts logging based on environment\nfunc WithEnvironmentAwareLogging(logger Logger) ewrap.Option {\n    return func(err *ewrap.Error) {\n        env := os.Getenv(\"APP_ENV\")\n\n        switch env {\n        case \"production\":\n            // Use production logger settings\n            err.WithMetadata(\"log_level\", \"error\")\n            err.WithMetadata(\"include_stack\", true)\n        case \"development\":\n            // Use development logger settings\n            err.WithMetadata(\"log_level\", \"debug\")\n            err.WithMetadata(\"include_stack\", true)\n        default:\n            // Use default settings\n            err.WithMetadata(\"log_level\", \"info\")\n        }\n\n        err.SetLogger(logger)\n    }\n}\n</code></pre>"},{"location":"api/overview/","title":"Package Overview","text":"<p>The ewrap package provides a sophisticated error handling solution for Go applications, combining modern error handling patterns with performance optimizations and developer-friendly features. This overview explains how the package's components work together to create a comprehensive error handling system.</p>"},{"location":"api/overview/#core-philosophy","title":"Core Philosophy","text":"<p>ewrap is built on several key principles:</p> <ol> <li>Rich Context: Errors should carry enough information to understand what went wrong, where, and why</li> <li>Performance: Error handling shouldn't become a bottleneck in your application</li> <li>Developer Experience: Clear, consistent patterns that make error handling both powerful and approachable</li> <li>Flexibility: Easy integration with existing systems and adaptable to different needs</li> <li>Production Readiness: Built-in support for logging, monitoring, and debugging</li> </ol>"},{"location":"api/overview/#component-architecture","title":"Component Architecture","text":""},{"location":"api/overview/#error-types-and-context","title":"Error Types and Context","text":"<p>At the heart of ewrap is the Error type, which provides the foundation for all error handling:</p> <pre><code>// Core error structure\ntype Error struct {\n    msg      string\n    cause    error\n    stack    []uintptr\n    metadata map[string]interface{}\n    logger   Logger\n    mu       sync.RWMutex\n}\n\n// Error context structure\ntype ErrorContext struct {\n    Timestamp   time.Time\n    Type        ErrorType\n    Severity    Severity\n    Operation   string\n    Component   string\n    RequestID   string\n    User        string\n    Environment string\n    Version     string\n    File        string\n    Line        int\n    Data        map[string]interface{}\n}\n</code></pre> <p>This structure allows errors to carry:</p> <ul> <li>Stack traces for debugging</li> <li>Metadata for context</li> <li>Logging configuration</li> <li>Error categorization</li> <li>Severity levels</li> <li>Operation tracking</li> </ul>"},{"location":"api/overview/#memory-management","title":"Memory Management","text":"<p>The package includes sophisticated memory management through pooling:</p> <pre><code>// Error group pooling\npool := ewrap.NewErrorGroupPool(4)\neg := pool.Get()\ndefer eg.Release()\n\n// Usage in high-throughput scenarios\nfor item := range items {\n    if err := processItem(item); err != nil {\n        eg.Add(err)\n    }\n}\n</code></pre> <p>This system helps reduce garbage collection pressure in applications that handle many errors.</p>"},{"location":"api/overview/#logging-integration","title":"Logging Integration","text":"<p>The logging system is designed for flexibility and integration with existing logging frameworks:</p> <pre><code>// Logger interface\ntype Logger interface {\n    Error(msg string, keysAndValues ...interface{})\n    Debug(msg string, keysAndValues ...interface{})\n    Info(msg string, keysAndValues ...interface{})\n}\n</code></pre> <p>Built-in adapters support popular logging frameworks while allowing custom implementations.</p>"},{"location":"api/overview/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>The circuit breaker implementation provides protection against cascading failures:</p> <pre><code>type CircuitBreaker struct {\n    name           string\n    maxFailures    int\n    timeout        time.Duration\n    failureCount   int\n    lastFailure    time.Time\n    state          CircuitState\n    mu             sync.RWMutex\n    onStateChange  func(name string, from, to CircuitState)\n}\n</code></pre> <p>This helps build resilient systems that can gracefully handle service degradation.</p>"},{"location":"api/overview/#feature-integration","title":"Feature Integration","text":""},{"location":"api/overview/#error-creation-and-wrapping","title":"Error Creation and Wrapping","text":"<p>The package provides a fluent API for error creation and wrapping:</p> <pre><code>// Error creation\nerr := ewrap.New(\"operation failed\",\n    ewrap.WithContext(ctx, ErrorTypeInternal, SeverityError),\n    ewrap.WithLogger(logger))\n\n// Error wrapping\nif err != nil {\n    return ewrap.Wrap(err, \"processing failed\",\n        ewrap.WithContext(ctx, ErrorTypeInternal, SeverityError))\n}\n</code></pre>"},{"location":"api/overview/#error-groups-and-concurrency","title":"Error Groups and Concurrency","text":"<p>Error groups handle concurrent error collection with built-in synchronization:</p> <pre><code>func processItems(items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            if err := processItem(item); err != nil {\n                eg.Add(err)\n            }\n        }(item)\n    }\n    wg.Wait()\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"api/overview/#performance-considerations","title":"Performance Considerations","text":"<p>The package includes several optimizations:</p> <ol> <li>Memory Pooling: Reduces allocation overhead</li> <li>Lock-Free Operations: Where possible, for better concurrency</li> <li>Efficient Stack Traces: Captures only necessary frames</li> <li>Lazy Formatting: Defers expensive string operations</li> </ol>"},{"location":"api/overview/#best-practices","title":"Best Practices","text":"<p>To get the most out of ewrap:</p> <ol> <li>Use Error Types Consistently: Choose appropriate error types for better error handling:</li> </ol> <pre><code>ErrorTypeValidation  // For input validation\nErrorTypeDatabase    // For database operations\nErrorTypeNetwork     // For network operations\n</code></pre> <ol> <li>Leverage Context: Add relevant context to errors:</li> </ol> <pre><code>ewrap.WithContext(ctx, errorType, severity)\n</code></pre> <ol> <li>Implement Proper Logging: Use structured logging for better debugging:</li> </ol> <pre><code>ewrap.WithLogger(logger)\n</code></pre> <ol> <li>Use Error Groups Efficiently: Pool error groups for better performance:</li> </ol> <pre><code>pool := ewrap.NewErrorGroupPool(size)\n</code></pre> <ol> <li>Handle Circuit Breaking: Protect your system from cascading failures:</li> </ol> <pre><code>breaker := ewrap.NewCircuitBreaker(name, maxFailures, timeout)\n</code></pre>"},{"location":"api/overview/#common-patterns","title":"Common Patterns","text":""},{"location":"api/overview/#request-handling","title":"Request Handling","text":"<pre><code>func handleRequest(w http.ResponseWriter, r *http.Request) {\n    ctx := r.Context()\n\n    // Get error group from pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Process request\n    if err := processRequest(ctx, r); err != nil {\n        eg.Add(ewrap.Wrap(err, \"request processing failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)))\n    }\n\n    // Handle any errors\n    if err := eg.Error(); err != nil {\n        handleError(w, err)\n        return\n    }\n\n    // Send success response\n    respondSuccess(w)\n}\n</code></pre>"},{"location":"api/overview/#service-integration","title":"Service Integration","text":"<pre><code>type Service struct {\n    breaker *ewrap.CircuitBreaker\n    logger  Logger\n}\n\nfunc (s *Service) CallExternalService(ctx context.Context) error {\n    if !s.breaker.CanExecute() {\n        return ewrap.New(\"service unavailable\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityCritical),\n            ewrap.WithLogger(s.logger))\n    }\n\n    if err := makeExternalCall(); err != nil {\n        s.breaker.RecordFailure()\n        return ewrap.Wrap(err, \"external call failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityError))\n    }\n\n    s.breaker.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"api/overview/#integration-points","title":"Integration Points","text":"<p>ewrap is designed to integrate with:</p> <ul> <li>Logging frameworks (zap, logrus, zerolog)</li> <li>Monitoring systems</li> <li>Tracing solutions</li> <li>HTTP middleware</li> <li>Database layers</li> <li>External services</li> </ul>"},{"location":"api/overview/#version-compatibility","title":"Version Compatibility","text":"<p>The package is compatible with:</p> <ul> <li>Go 1.13+ error wrapping</li> <li>Standard library contexts</li> <li>Common logging frameworks</li> <li>Standard HTTP packages</li> <li>Database/SQL interfaces</li> </ul>"},{"location":"api/overview/#further-reading","title":"Further Reading","text":"<p>For more detailed information about specific features, refer to:</p> <ul> <li>Error Types Documentation</li> <li>Circuit Breaker Documentation</li> <li>Error Groups Documentation</li> <li>Logging Integration</li> <li>Context Integration</li> </ul>"},{"location":"features/circuit-breaker/","title":"Circuit Breaker Pattern","text":"<p>The Circuit Breaker pattern is like a safety switch in an electrical system - it prevents cascade failures by \"breaking the circuit\" when too many errors occur. This pattern is crucial for building resilient systems that can gracefully handle failures in distributed environments.</p>"},{"location":"features/circuit-breaker/#understanding-circuit-breakers","title":"Understanding Circuit Breakers","text":"<p>Imagine you're calling a database service. Without a circuit breaker, if the database becomes slow or unresponsive, your application might:</p> <ol> <li>Keep trying and failing</li> <li>Accumulate resource-consuming connections</li> <li>Eventually crash or become unresponsive itself</li> </ol> <p>A circuit breaker prevents this by monitoring failures and automatically stopping attempts when a threshold is reached, giving the system time to recover.</p>"},{"location":"features/circuit-breaker/#basic-circuit-breaker-usage","title":"Basic Circuit Breaker Usage","text":"<p>Let's start with a simple example of how to use circuit breakers in ewrap:</p> <pre><code>// Create a circuit breaker that will:\n// - Open after 5 failures\n// - Stay open for 1 minute before attempting recovery\ncb := ewrap.NewCircuitBreaker(\"database-operations\", 5, time.Minute)\n\nfunc queryDatabase() error {\n    // Check if we can execute the operation\n    if !cb.CanExecute() {\n        return ewrap.New(\"circuit breaker is open\",\n            ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n            ewrap.WithMetadata(\"breaker_name\", \"database-operations\"))\n    }\n\n    err := performDatabaseQuery()\n    if err != nil {\n        // Record the failure\n        cb.RecordFailure()\n        return ewrap.Wrap(err, \"database query failed\")\n    }\n\n    // Record the success\n    cb.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"features/circuit-breaker/#circuit-breaker-states","title":"Circuit Breaker States","text":"<p>A circuit breaker can be in one of three states:</p>"},{"location":"features/circuit-breaker/#closed-state-normal-operation","title":"Closed State (Normal Operation)","text":"<pre><code>if cb.CanExecute() {  // Returns true when circuit is closed\n    // Normal operation - requests are allowed through\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()\n    } else {\n        cb.RecordSuccess()\n    }\n}\n</code></pre>"},{"location":"features/circuit-breaker/#open-state-failure-prevention","title":"Open State (Failure Prevention)","text":"<pre><code>if !cb.CanExecute() {  // Returns false when circuit is open\n    // Circuit is open - fail fast without attempting operation\n    return ewrap.New(\"service unavailable\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithMetadata(\"circuit_state\", \"open\"))\n}\n</code></pre>"},{"location":"features/circuit-breaker/#half-open-state-recovery-attempt","title":"Half-Open State (Recovery Attempt)","text":"<pre><code>// After timeout period, circuit moves to half-open\n// Allowing a single request through to test the service\nif cb.CanExecute() {\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()  // Returns to open state\n        return err\n    }\n    cb.RecordSuccess()  // Returns to closed state\n    return nil\n}\n</code></pre>"},{"location":"features/circuit-breaker/#advanced-circuit-breaker-patterns","title":"Advanced Circuit Breaker Patterns","text":""},{"location":"features/circuit-breaker/#monitoring-multiple-services","title":"Monitoring Multiple Services","text":"<p>When your application depends on multiple services, you can use separate circuit breakers for each:</p> <pre><code>type ServiceManager struct {\n    dbBreaker    *ewrap.CircuitBreaker\n    cacheBreaker *ewrap.CircuitBreaker\n    apiBreaker   *ewrap.CircuitBreaker\n}\n\nfunc NewServiceManager() *ServiceManager {\n    return &amp;ServiceManager{\n        dbBreaker:    ewrap.NewCircuitBreaker(\"database\", 5, time.Minute),\n        cacheBreaker: ewrap.NewCircuitBreaker(\"cache\", 3, time.Second*30),\n        apiBreaker:   ewrap.NewCircuitBreaker(\"external-api\", 10, time.Minute*2),\n    }\n}\n\nfunc (sm *ServiceManager) GetUserData(userID string) (*UserData, error) {\n    // Try cache first\n    if sm.cacheBreaker.CanExecute() {\n        data, err := tryCache(userID)\n        if err == nil {\n            sm.cacheBreaker.RecordSuccess()\n            return data, nil\n        }\n        sm.cacheBreaker.RecordFailure()\n    }\n\n    // Fall back to database\n    if sm.dbBreaker.CanExecute() {\n        data, err := queryDatabase(userID)\n        if err == nil {\n            sm.dbBreaker.RecordSuccess()\n            return data, nil\n        }\n        sm.dbBreaker.RecordFailure()\n    }\n\n    return nil, ewrap.New(\"all data sources unavailable\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithSeverity(ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"features/circuit-breaker/#circuit-breaker-with-fallback-strategies","title":"Circuit Breaker with Fallback Strategies","text":"<p>Implement graceful degradation when services fail:</p> <pre><code>type CacheService struct {\n    primaryBreaker   *ewrap.CircuitBreaker\n    secondaryBreaker *ewrap.CircuitBreaker\n    localCache       *cache.Cache\n}\n\nfunc (cs *CacheService) GetValue(key string) (interface{}, error) {\n    // Try primary cache\n    if cs.primaryBreaker.CanExecute() {\n        value, err := cs.getPrimaryCache(key)\n        if err == nil {\n            cs.primaryBreaker.RecordSuccess()\n            return value, nil\n        }\n        cs.primaryBreaker.RecordFailure()\n    }\n\n    // Try secondary cache\n    if cs.secondaryBreaker.CanExecute() {\n        value, err := cs.getSecondaryCache(key)\n        if err == nil {\n            cs.secondaryBreaker.RecordSuccess()\n            return value, nil\n        }\n        cs.secondaryBreaker.RecordFailure()\n    }\n\n    // Fall back to local cache\n    if value, found := cs.localCache.Get(key); found {\n        return value, nil\n    }\n\n    return nil, ewrap.New(\"all cache layers unavailable\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal))\n}\n</code></pre>"},{"location":"features/circuit-breaker/#combining-with-error-groups","title":"Combining with Error Groups","text":"<p>Circuit Breakers work particularly well with Error Groups for batch operations:</p> <pre><code>func processBatch(items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    cb := ewrap.NewCircuitBreaker(\"batch-processor\", 5, time.Minute)\n\n    for _, item := range items {\n        if !cb.CanExecute() {\n            eg.Add(ewrap.New(\"circuit breaker open: too many failures\"))\n            break\n        }\n\n        if err := processItem(item); err != nil {\n            cb.RecordFailure()\n            eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n        } else {\n            cb.RecordSuccess()\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"features/circuit-breaker/#best-practices","title":"Best Practices","text":""},{"location":"features/circuit-breaker/#1-choose-appropriate-thresholds","title":"1. Choose Appropriate Thresholds","text":"<p>Consider your service's characteristics when configuring circuit breakers:</p> <pre><code>// For critical, fast operations\ncb := ewrap.NewCircuitBreaker(\"critical-service\", 3, time.Second*30)\n\n// For less critical, slower operations\ncb := ewrap.NewCircuitBreaker(\"background-service\", 10, time.Minute*5)\n</code></pre>"},{"location":"features/circuit-breaker/#2-monitor-circuit-breaker-states","title":"2. Monitor Circuit Breaker States","text":"<p>Implement monitoring to track circuit breaker behavior:</p> <pre><code>type MonitoredCircuitBreaker struct {\n    *ewrap.CircuitBreaker\n    metrics *metrics.Recorder\n}\n\nfunc (mcb *MonitoredCircuitBreaker) RecordFailure() {\n    mcb.CircuitBreaker.RecordFailure()\n    mcb.metrics.Increment(\"circuit_breaker.failures\")\n}\n\nfunc (mcb *MonitoredCircuitBreaker) RecordSuccess() {\n    mcb.CircuitBreaker.RecordSuccess()\n    mcb.metrics.Increment(\"circuit_breaker.successes\")\n}\n</code></pre>"},{"location":"features/circuit-breaker/#3-implement-graceful-degradation","title":"3. Implement Graceful Degradation","text":"<p>Plan for circuit breaker activation:</p> <pre><code>func getUserProfile(userID string) (*Profile, error) {\n    if !profileBreaker.CanExecute() {\n        // Return cached or minimal profile when circuit is open\n        return getMinimalProfile(userID)\n    }\n\n    profile, err := getFullProfile(userID)\n    if err != nil {\n        profileBreaker.RecordFailure()\n        // Fall back to minimal profile\n        return getMinimalProfile(userID)\n    }\n\n    profileBreaker.RecordSuccess()\n    return profile, nil\n}\n</code></pre>"},{"location":"features/circuit-breaker/#4-use-context-aware-circuit-breakers","title":"4. Use Context-Aware Circuit Breakers","text":"<p>Consider request context when making circuit breaker decisions:</p> <pre><code>func processWithContext(ctx context.Context, data []byte) error {\n    if deadline, ok := ctx.Deadline(); ok {\n        // Adjust circuit breaker timeout based on context deadline\n        timeout := time.Until(deadline)\n        cb := ewrap.NewCircuitBreaker(\"context-aware\", 5, timeout/2)\n\n        if !cb.CanExecute() {\n            return ewrap.New(\"circuit breaker open\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeTimeout, ewrap.SeverityWarning))\n        }\n        // Process with context-aware circuit breaker\n    }\n    // ... rest of processing\n}\n</code></pre>"},{"location":"features/error-creation/","title":"Error Creation","text":"<p>Understanding how to create errors effectively is fundamental to using the ewrap package. This guide explains the different ways to create errors and when to use each approach.</p>"},{"location":"features/error-creation/#basic-error-creation","title":"Basic Error Creation","text":"<p>The most straightforward way to create an error is using the <code>New</code> function. However, there's more to consider than just the error message.</p> <pre><code>// Simple error creation\nerr := ewrap.New(\"user not found\")\n\n// With additional context\nerr := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError),\n    ewrap.WithLogger(logger))\n</code></pre> <p>The <code>New</code> function captures a stack trace automatically, allowing you to trace the error's origin later. This is particularly valuable when debugging complex applications where errors might surface far from their source.</p>"},{"location":"features/error-creation/#creating-errors-with-options","title":"Creating Errors with Options","text":"<p>The <code>New</code> function accepts variadic options that configure the error's behavior and context:</p> <pre><code>err := ewrap.New(\"failed to process payment\",\n    // Add request context\n    ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical),\n    // Configure logging\n    ewrap.WithLogger(logger),\n    // Add retry information\n    ewrap.WithRetry(3, time.Second*5))\n</code></pre> <p>Each option serves a specific purpose:</p> <ul> <li><code>WithContext</code>: Adds request context and error classification</li> <li><code>WithLogger</code>: Configures error logging behavior</li> <li><code>WithRetry</code>: Specifies retry behavior for recoverable errors</li> </ul>"},{"location":"features/error-creation/#creating-domain-specific-errors","title":"Creating Domain-Specific Errors","text":"<p>For domain-specific error cases, you can combine error creation with metadata:</p> <pre><code>func validateUserAge(age int) error {\n    if age &lt; 18 {\n        return ewrap.New(\"user is underage\",\n            ewrap.WithContext(context.Background(), ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"minimum_age\", 18).\n            WithMetadata(\"provided_age\", age)\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-creation/#best-practices-for-error-creation","title":"Best Practices for Error Creation","text":"<p>When creating errors, follow these guidelines for maximum effectiveness:</p> <ol> <li> <p>Be Specific: Error messages should clearly indicate what went wrong:</p> <pre><code>// Good\nerr := ewrap.New(\"database connection timeout after 5 seconds\")\n\n// Not as helpful\nerr := ewrap.New(\"database error\")\n</code></pre> </li> <li> <p>Include Relevant Context: Add context that helps with debugging:</p> <pre><code>err := ewrap.New(\"failed to update user profile\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError)).\n    WithMetadata(\"user_id\", userID).\n    WithMetadata(\"fields_updated\", fields)\n</code></pre> </li> <li> <p>Use Appropriate Error Types: Choose error types that match the situation:</p> <pre><code>// For validation errors\nerr := ewrap.New(\"invalid email format\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityWarning))\n\n// For system errors\nerr := ewrap.New(\"failed to connect to database\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n</code></pre> </li> <li> <p>Consider Recovery Options: Include information that helps with recovery:</p> <pre><code>err := ewrap.New(\"rate limit exceeded\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityWarning)).\n    WithMetadata(\"retry_after\", time.Now().Add(time.Minute)).\n    WithMetadata(\"current_rate\", currentRate).\n    WithMetadata(\"limit\", rateLimit)\n</code></pre> </li> </ol>"},{"location":"features/error-creation/#working-with-stack-traces","title":"Working with Stack Traces","text":"<p>Every error created with <code>New</code> automatically captures a stack trace:</p> <pre><code>func processOrder(orderID string) error {\n    err := ewrap.New(\"order processing failed\")\n    fmt.Println(err.Stack()) // Prints the stack trace\n    return err\n}\n</code></pre> <p>The stack trace includes function names, file names, and line numbers, making it easier to trace the error's origin.</p>"},{"location":"features/error-creation/#error-creation-in-tests","title":"Error Creation in Tests","text":"<p>When writing tests, you might want to create errors for specific scenarios:</p> <pre><code>func TestOrderProcessing(t *testing.T) {\n    // Create a test error\n    testErr := ewrap.New(\"simulated database error\",\n        ewrap.WithContext(context.Background(), ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n\n    // Mock database returns our test error\n    mockDB := &amp;MockDatabase{\n        QueryFunc: func() error {\n            return testErr\n        },\n    }\n\n    err := processOrder(mockDB, \"order123\")\n\n    // Verify error handling\n    if !errors.Is(err, testErr) {\n        t.Errorf(\"expected error %v, got %v\", testErr, err)\n    }\n}\n</code></pre>"},{"location":"features/error-creation/#thread-safety","title":"Thread Safety","text":"<p>All error creation operations in ewrap are thread-safe. You can safely create errors from multiple goroutines:</p> <pre><code>func processItems(items []string) []error {\n    var wg sync.WaitGroup\n    errors := make([]error, 0)\n    var mu sync.Mutex\n\n    for _, item := range items {\n        wg.Add(1)\n        go func(item string) {\n            defer wg.Done()\n            if err := process(item); err != nil {\n                mu.Lock()\n                errors = append(errors, ewrap.New(\"processing failed\",\n                    ewrap.WithMetadata(\"item\", item)))\n                mu.Unlock()\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return errors\n}\n</code></pre>"},{"location":"features/error-creation/#performance-considerations","title":"Performance Considerations","text":"<p>Error creation in ewrap is optimized for both CPU and memory usage. However, consider these performance tips:</p> <ol> <li>Reuse error types for common errors instead of creating new ones</li> <li>Only capture stack traces when necessary</li> <li>Be mindful of metadata quantity in high-throughput scenarios</li> <li>Use error pools for frequent error creation scenarios</li> </ol> <p>Remember: error creation should be reserved for exceptional cases. Don't use errors for normal control flow in your application.</p>"},{"location":"features/error-groups/","title":"Error Groups","text":"<p>Error Groups in ewrap provide a powerful way to collect, manage, and handle multiple errors together. They are particularly useful in concurrent operations, validation scenarios, or any situation where multiple errors might occur and need to be handled cohesively.</p>"},{"location":"features/error-groups/#understanding-error-groups","title":"Understanding Error Groups","text":"<p>An Error Group acts as a thread-safe container for multiple errors. Think of it as a collector that can gather errors from various operations while ensuring that all errors are properly tracked and can be processed together. What makes our implementation special is its efficient memory usage through a pooling mechanism.</p>"},{"location":"features/error-groups/#basic-usage","title":"Basic Usage","text":"<p>Let's start with the fundamental ways to use Error Groups:</p> <pre><code>// Create a pool for error groups\npool := ewrap.NewErrorGroupPool(4)  // Initial capacity of 4 errors\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Don't forget to release it back to the pool\n\n// Add errors to the group\neg.Add(ewrap.New(\"validation failed for email\"))\neg.Add(ewrap.New(\"validation failed for password\"))\n\n// Check if there are any errors\nif eg.HasErrors() {\n    fmt.Printf(\"Encountered errors: %v\\n\", eg.Error())\n}\n</code></pre>"},{"location":"features/error-groups/#error-group-pooling","title":"Error Group Pooling","text":"<p>Our Error Group implementation uses a pool to reuse instances efficiently. This is particularly valuable in high-throughput scenarios where creating and destroying error groups frequently could impact performance.</p>"},{"location":"features/error-groups/#how-pooling-works","title":"How Pooling Works","text":"<p>The pooling mechanism works behind the scenes to manage memory efficiently:</p> <pre><code>// Create a pool with specific capacity\npool := ewrap.NewErrorGroupPool(4)\n\nfunc processUserRegistration(user User) error {\n    // Get an error group from the pool\n    eg := pool.Get()\n    defer eg.Release()  // Returns the group to the pool when done\n\n    // Validate different aspects of the user\n    if err := validateEmail(user.Email); err != nil {\n        eg.Add(err)\n    }\n\n    if err := validatePassword(user.Password); err != nil {\n        eg.Add(err)\n    }\n\n    if err := validateAge(user.Age); err != nil {\n        eg.Add(err)\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"features/error-groups/#concurrent-operations","title":"Concurrent Operations","text":"<p>Error Groups are particularly useful in concurrent operations. They're designed to be thread-safe and can safely collect errors from multiple goroutines:</p> <pre><code>func processItems(items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n\n            if err := processItem(item); err != nil {\n                eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return eg.Error()\n}\n</code></pre>"},{"location":"features/error-groups/#validation-scenarios","title":"Validation Scenarios","text":"<p>Error Groups excel at collecting validation errors, allowing you to report all validation failures at once rather than stopping at the first error:</p> <pre><code>func validateUser(user User) error {\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate email format\n    if !isValidEmail(user.Email) {\n        eg.Add(ewrap.New(\"invalid email format\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate password strength\n    if !isStrongPassword(user.Password) {\n        eg.Add(ewrap.New(\"password too weak\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate age\n    if user.Age &lt; 18 {\n        eg.Add(ewrap.New(\"user must be 18 or older\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"features/error-groups/#advanced-usage-patterns","title":"Advanced Usage Patterns","text":""},{"location":"features/error-groups/#hierarchical-error-collection","title":"Hierarchical Error Collection","text":"<p>You can create hierarchical error structures by nesting error groups:</p> <pre><code>func validateOrder(order Order) error {\n    mainPool := ewrap.NewErrorGroupPool(2)\n    mainGroup := mainPool.Get()\n    defer mainGroup.Release()\n\n    // Validate customer details\n    if err := func() error {\n        customerPool := ewrap.NewErrorGroupPool(3)\n        customerGroup := customerPool.Get()\n        defer customerGroup.Release()\n\n        if err := validateCustomerEmail(order.Customer.Email); err != nil {\n            customerGroup.Add(err)\n        }\n        if err := validateCustomerAddress(order.Customer.Address); err != nil {\n            customerGroup.Add(err)\n        }\n\n        return customerGroup.Error()\n    }(); err != nil {\n        mainGroup.Add(ewrap.Wrap(err, \"customer validation failed\"))\n    }\n\n    // Validate order items\n    if err := func() error {\n        itemsPool := ewrap.NewErrorGroupPool(len(order.Items))\n        itemsGroup := itemsPool.Get()\n        defer itemsGroup.Release()\n\n        for _, item := range order.Items {\n            if err := validateOrderItem(item); err != nil {\n                itemsGroup.Add(err)\n            }\n        }\n\n        return itemsGroup.Error()\n    }(); err != nil {\n        mainGroup.Add(ewrap.Wrap(err, \"order items validation failed\"))\n    }\n\n    return mainGroup.Error()\n}\n</code></pre>"},{"location":"features/error-groups/#error-group-with-circuit-breaker","title":"Error Group with Circuit Breaker","text":"<p>Combine Error Groups with Circuit Breakers for robust error handling:</p> <pre><code>func processOrderBatch(orders []Order) error {\n    pool := ewrap.NewErrorGroupPool(len(orders))\n    eg := pool.Get()\n    defer eg.Release()\n\n    cb := ewrap.NewCircuitBreaker(\"order-processing\", 5, time.Minute)\n\n    for _, order := range orders {\n        if !cb.CanExecute() {\n            eg.Add(ewrap.New(\"circuit breaker open: too many failures\",\n                ewrap.WithErrorType(ewrap.ErrorTypeInternal)))\n            break\n        }\n\n        if err := processOrder(order); err != nil {\n            cb.RecordFailure()\n            eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process order %s\", order.ID)))\n        } else {\n            cb.RecordSuccess()\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"features/error-groups/#performance-considerations","title":"Performance Considerations","text":"<p>The pooled Error Group implementation is designed for high performance, but there are some best practices to follow:</p> <ol> <li> <p>Choose Appropriate Pool Capacity:</p> <pre><code>// For known size operations\npool := ewrap.NewErrorGroupPool(len(items))\n\n// For variable size operations, estimate typical case\npool := ewrap.NewErrorGroupPool(4)  // If you typically expect 1-4 errors\n</code></pre> </li> <li> <p>Release Groups Properly:</p> <pre><code>func processWithErrors() error {\n    eg := pool.Get()\n    // Always release with defer to prevent leaks\n    defer eg.Release()\n\n    // Use the error group...\n    return eg.Error()\n}\n</code></pre> </li> <li> <p>Reuse Pools:</p> <pre><code>// Good: Create pool once and reuse\nvar validationPool = ewrap.NewErrorGroupPool(4)\n\nfunc validateData(data Data) error {\n    eg := validationPool.Get()\n    defer eg.Release()\n    // Use the error group...\n}\n\n// Less efficient: Creating new pools frequently\nfunc validateData(data Data) error {\n    pool := ewrap.NewErrorGroupPool(4)  // Don't do this\n    eg := pool.Get()\n    // ...\n}\n</code></pre> </li> </ol>"},{"location":"features/error-groups/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always Release Error Groups:     Use defer to ensure Error Groups are always released back to their pool:</p> <pre><code>eg := pool.Get()\ndefer eg.Release()\n</code></pre> </li> <li> <p>Size Pools Appropriately:     Choose pool sizes based on your expected error cases:</p> <pre><code>// For validation where you know the maximum possible errors\npool := ewrap.NewErrorGroupPool(len(validationRules))\n</code></pre> </li> <li> <p>Handle Nested Operations: When dealing with nested operations, manage Error Groups carefully:</p> </li> </ol> <pre><code>func processComplex() error {\n    outerPool := ewrap.NewErrorGroupPool(2)\n    outerGroup := outerPool.Get()\n    defer outerGroup.Release()\n\n    for _, item := range items {\n        innerPool := ewrap.NewErrorGroupPool(4)\n        innerGroup := innerPool.Get()\n\n        // Process with inner group...\n\n        if err := innerGroup.Error(); err != nil {\n            outerGroup.Add(err)\n        }\n        innerGroup.Release()\n    }\n\n    return outerGroup.Error()\n}\n</code></pre>"},{"location":"features/error-wrapping/","title":"Error Wrapping","text":"<p>Error wrapping is a powerful feature that allows you to add context to errors as they propagate through your application. Understanding how to effectively wrap errors can significantly improve your application's debuggability and error handling capabilities.</p>"},{"location":"features/error-wrapping/#understanding-error-wrapping","title":"Understanding Error Wrapping","text":"<p>When an error occurs deep in your application's call stack, it often needs to pass through several layers before being handled. Each layer might need to add its own context to the error, helping to tell the complete story of what went wrong.</p> <p>Consider this scenario:</p> <pre><code>func getUserProfile(userID string) (*Profile, error) {\n    // Low level database error occurs\n    data, err := db.Query(\"SELECT * FROM users WHERE id = ?\", userID)\n    if err != nil {\n        // We wrap the database error with our context\n        return nil, ewrap.Wrap(err, \"failed to fetch user data\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    // Error occurs during data processing\n    profile, err := parseUserData(data)\n    if err != nil {\n        // We wrap the parsing error with additional context\n        return nil, ewrap.Wrap(err, \"failed to parse user profile\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)).\n            WithMetadata(\"user_id\", userID)\n    }\n\n    return profile, nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#the-wrap-function","title":"The Wrap Function","text":"<p>The <code>Wrap</code> function is the primary tool for error wrapping. It preserves the original error while adding new context:</p> <pre><code>func Wrap(err error, msg string, opts ...Option) *Error\n</code></pre> <p>The function takes:</p> <ul> <li>The original error</li> <li>A message describing what went wrong at this level</li> <li>Optional configuration options</li> </ul>"},{"location":"features/error-wrapping/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of error wrapping:</p> <pre><code>if err := validateInput(data); err != nil {\n    return ewrap.Wrap(err, \"input validation failed\")\n}\n</code></pre>"},{"location":"features/error-wrapping/#adding-context-while-wrapping","title":"Adding Context While Wrapping","text":"<p>You can add rich context while wrapping errors:</p> <pre><code>if err := processPayment(amount); err != nil {\n    return ewrap.Wrap(err, \"payment processing failed\",\n        ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityCritical),\n        ewrap.WithLogger(logger)).\n        WithMetadata(\"amount\", amount).\n        WithMetadata(\"currency\", \"USD\").\n        WithMetadata(\"processor\", \"stripe\")\n}\n</code></pre>"},{"location":"features/error-wrapping/#error-chain-preservation","title":"Error Chain Preservation","text":"<p>When you wrap an error, ewrap maintains the entire error chain. This means you can:</p> <ul> <li>Access the original error</li> <li>See all intermediate wrapping contexts</li> <li>Understand the complete error path</li> </ul> <pre><code>func main() {\n    err := processUserRequest()\n    if err != nil {\n        // Print the full error chain\n        fmt.Println(err)\n\n        // Access the root cause\n        cause := errors.Unwrap(err)\n\n        // Check if a specific error type exists in the chain\n        if errors.Is(err, sql.ErrNoRows) {\n            // Handle database not found case\n        }\n    }\n}\n</code></pre>"},{"location":"features/error-wrapping/#formatted-wrapping-with-wrapf","title":"Formatted Wrapping with Wrapf","text":"<p>For cases where you need to include formatted messages, use <code>Wrapf</code>:</p> <pre><code>func updateUser(userID string, fields map[string]interface{}) error {\n    if err := db.Update(userID, fields); err != nil {\n        return ewrap.Wrapf(err, \"failed to update user %s\", userID)\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#best-practices-for-error-wrapping","title":"Best Practices for Error Wrapping","text":""},{"location":"features/error-wrapping/#1-add-meaningful-context","title":"1. Add Meaningful Context","text":"<p>Each wrap should add valuable information:</p> <pre><code>// Good - adds specific context\nerr = ewrap.Wrap(err, \"failed to process monthly report for January 2024\",\n    ewrap.WithMetadata(\"report_type\", \"monthly\"),\n    ewrap.WithMetadata(\"period\", \"2024-01\"))\n\n// Not as helpful - too generic\nerr = ewrap.Wrap(err, \"processing failed\")\n</code></pre>"},{"location":"features/error-wrapping/#2-preserve-error-types","title":"2. Preserve Error Types","text":"<p>Choose error types that make sense for the current context:</p> <pre><code>func validateAndSaveUser(user User) error {\n    err := validateUser(user)\n    if err != nil {\n        // Preserve validation error type\n        return ewrap.Wrap(err, \"user validation failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityError))\n    }\n\n    err = saveUser(user)\n    if err != nil {\n        // Use database error type for storage issues\n        return ewrap.Wrap(err, \"failed to save user\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#3-use-appropriate-granularity","title":"3. Use Appropriate Granularity","text":"<p>Balance between too much and too little information:</p> <pre><code>func processOrder(order Order) error {\n    // Wrap high-level business operations\n    if err := validateOrder(order); err != nil {\n        return ewrap.Wrap(err, \"order validation failed\")\n    }\n\n    // Don't wrap every small utility function\n    total := calculateTotal(order.Items)\n\n    // Wrap significant state transitions or external calls\n    if err := chargeCustomer(order.CustomerID, total); err != nil {\n        return ewrap.Wrap(err, \"payment processing failed\",\n            ewrap.WithMetadata(\"amount\", total),\n            ewrap.WithMetadata(\"customer_id\", order.CustomerID))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#4-consider-performance","title":"4. Consider Performance","text":"<p>While error wrapping is lightweight, be mindful in hot paths:</p> <pre><code>func processItems(items []Item) error {\n    for _, item := range items {\n        // In tight loops, consider if wrapping is necessary\n        if err := validateItem(item); err != nil {\n            return err  // Maybe don't wrap simple validation errors\n        }\n\n        // Do wrap significant errors\n        if err := processItem(item); err != nil {\n            return ewrap.Wrap(err, \"item processing failed\",\n                ewrap.WithMetadata(\"item_id\", item.ID))\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#advanced-error-wrapping","title":"Advanced Error Wrapping","text":""},{"location":"features/error-wrapping/#conditional-wrapping","title":"Conditional Wrapping","text":"<p>Sometimes you might want to wrap errors differently based on their type:</p> <pre><code>func handleDatabaseOperation() error {\n    err := db.Query()\n    if err != nil {\n        switch {\n        case errors.Is(err, sql.ErrNoRows):\n            return ewrap.Wrap(err, \"record not found\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityWarning))\n        case errors.Is(err, sql.ErrConnDone):\n            return ewrap.Wrap(err, \"database connection lost\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n        default:\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/error-wrapping/#multi-level-wrapping","title":"Multi-Level Wrapping","text":"<p>For complex operations, you might wrap errors multiple times:</p> <pre><code>func processUserOrder(ctx context.Context, userID, orderID string) error {\n    user, err := getUser(userID)\n    if err != nil {\n        return ewrap.Wrap(err, \"failed to get user\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    order, err := getOrder(orderID)\n    if err != nil {\n        return ewrap.Wrap(err, \"failed to get order\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityError))\n    }\n\n    if err := validateUserCanAccessOrder(user, order); err != nil {\n        return ewrap.Wrap(err, \"user not authorized to access order\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypePermission, ewrap.SeverityWarning))\n    }\n\n    if err := processOrderPayment(order); err != nil {\n        return ewrap.Wrap(err, \"order payment failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeExternal, ewrap.SeverityCritical))\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/logging/","title":"Logging Integration","text":"<p>When errors occur in your application, having detailed, structured logs is crucial for understanding what went wrong and why. The ewrap package provides a flexible logging system that integrates seamlessly with popular logging frameworks while maintaining a clean, consistent interface for error logging.</p>"},{"location":"features/logging/#understanding-logging-in-ewrap","title":"Understanding Logging in ewrap","text":"<p>The logging system in ewrap is built around a simple yet powerful interface that can adapt to any logging framework. When an error occurs, ewrap can automatically log not just the error message, but also the stack trace, metadata, and contextual information that helps tell the complete story of what happened.</p>"},{"location":"features/logging/#the-logger-interface","title":"The Logger Interface","text":"<p>Let's start by understanding the core logging interface:</p> <pre><code>type Logger interface {\n    Error(msg string, keysAndValues ...interface{})\n    Debug(msg string, keysAndValues ...interface{})\n    Info(msg string, keysAndValues ...interface{})\n}\n</code></pre> <p>This interface is intentionally simple to make it easy to adapt any logging framework to work with ewrap. The variadic <code>keysAndValues</code> parameter allows for structured logging where key-value pairs provide additional context.</p>"},{"location":"features/logging/#built-in-logging-adapters","title":"Built-in Logging Adapters","text":"<p>ewrap provides adapters for popular logging frameworks. Here's how to use them:</p>"},{"location":"features/logging/#zap-logger-integration","title":"Zap Logger Integration","text":"<pre><code>import (\n    \"go.uber.org/zap\"\n    \"github.com/hyp3rd/ewrap/adapters\"\n)\n\nfunc setupZapLogger() error {\n    // Create a production-ready Zap logger\n    zapLogger, err := zap.NewProduction()\n    if err != nil {\n        return err\n    }\n\n    // Create the adapter\n    logger := adapters.NewZapAdapter(zapLogger)\n\n    // Create an error with logging enabled\n    err = ewrap.New(\"operation failed\",\n        ewrap.WithLogger(logger),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)).\n        WithMetadata(\"operation\", \"user_update\").\n        WithMetadata(\"user_id\", userID)\n\n    // The error will be automatically logged with all context\n    return err\n}\n</code></pre>"},{"location":"features/logging/#logrus-integration","title":"Logrus Integration","text":"<pre><code>import (\n    \"github.com/sirupsen/logrus\"\n    \"github.com/hyp3rd/ewrap/adapters\"\n)\n\nfunc setupLogrusLogger() error {\n    // Configure Logrus\n    logrusLogger := logrus.New()\n    logrusLogger.SetFormatter(&amp;logrus.JSONFormatter{})\n\n    // Create the adapter\n    logger := adapters.NewLogrusAdapter(logrusLogger)\n\n    // Use the logger with ewrap\n    return ewrap.New(\"database connection failed\",\n        ewrap.WithLogger(logger),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"features/logging/#zerolog-integration","title":"Zerolog Integration","text":"<pre><code>import (\n    \"github.com/rs/zerolog\"\n    \"github.com/hyp3rd/ewrap/adapters\"\n)\n\nfunc setupZerolog() error {\n    // Configure Zerolog\n    zerologLogger := zerolog.New(os.Stdout).With().Timestamp().Logger()\n\n    // Create the adapter\n    logger := adapters.NewZerologAdapter(zerologLogger)\n\n    // Use with ewrap\n    return ewrap.New(\"request validation failed\",\n        ewrap.WithLogger(logger),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityWarning))\n}\n</code></pre>"},{"location":"features/logging/#advanced-logging-patterns","title":"Advanced Logging Patterns","text":""},{"location":"features/logging/#contextual-logging","title":"Contextual Logging","text":"<p>Here's how to create rich, contextual logs that capture the full story of an error:</p> <pre><code>func processOrder(ctx context.Context, order Order) error {\n    logger := getContextLogger(ctx)\n\n    // Create an operation logger that will track the entire process\n    opLogger := &amp;OperationLogger{\n        Logger:    logger,\n        Operation: \"process_order\",\n        StartTime: time.Now(),\n        Context:   map[string]interface{}{\n            \"order_id\": order.ID,\n            \"user_id\":  order.UserID,\n        },\n    }\n\n    // Log operation start\n    opLogger.Info(\"starting order processing\")\n\n    if err := validateOrder(order); err != nil {\n        return ewrap.Wrap(err, \"order validation failed\",\n            ewrap.WithLogger(opLogger),\n            ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"validation_time\", time.Since(opLogger.StartTime))\n    }\n\n    if err := processPayment(order); err != nil {\n        return ewrap.Wrap(err, \"payment processing failed\",\n            ewrap.WithLogger(opLogger),\n            ewrap.WithContext(ctx, ewrap.ErrorTypePayment, ewrap.SeverityCritical)).\n            WithMetadata(\"processing_time\", time.Since(opLogger.StartTime))\n    }\n\n    // Log successful completion\n    opLogger.Info(\"order processed successfully\",\n        \"duration\", time.Since(opLogger.StartTime))\n\n    return nil\n}\n</code></pre>"},{"location":"features/logging/#creating-a-custom-logger","title":"Creating a Custom Logger","text":"<p>You might want to create a custom logger that adds specific functionality:</p> <pre><code>type CustomLogger struct {\n    logger    Logger\n    component string\n    env       string\n}\n\nfunc NewCustomLogger(baseLogger Logger, component string) *CustomLogger {\n    return &amp;CustomLogger{\n        logger:    baseLogger,\n        component: component,\n        env:       os.Getenv(\"APP_ENV\"),\n    }\n}\n\nfunc (l *CustomLogger) Error(msg string, keysAndValues ...interface{}) {\n    // Add standard context to all error logs\n    enrichedKV := append([]interface{}{\n        \"component\", l.component,\n        \"environment\", l.env,\n        \"timestamp\", time.Now().UTC(),\n    }, keysAndValues...)\n\n    l.logger.Error(msg, enrichedKV...)\n}\n\nfunc (l *CustomLogger) Debug(msg string, keysAndValues ...interface{}) {\n    enrichedKV := append([]interface{}{\n        \"component\", l.component,\n        \"environment\", l.env,\n    }, keysAndValues...)\n\n    l.logger.Debug(msg, enrichedKV...)\n}\n\nfunc (l *CustomLogger) Info(msg string, keysAndValues ...interface{}) {\n    enrichedKV := append([]interface{}{\n        \"component\", l.component,\n        \"environment\", l.env,\n    }, keysAndValues...)\n\n    l.logger.Info(msg, enrichedKV...)\n}\n</code></pre>"},{"location":"features/logging/#logging-with-circuit-breakers","title":"Logging with Circuit Breakers","text":"<p>Combining logging with circuit breakers provides insight into system health:</p> <pre><code>type MonitoredCircuitBreaker struct {\n    *ewrap.CircuitBreaker\n    logger Logger\n    name   string\n}\n\nfunc NewMonitoredCircuitBreaker(name string, maxFailures int, timeout time.Duration, logger Logger) *MonitoredCircuitBreaker {\n    cb := ewrap.NewCircuitBreaker(name, maxFailures, timeout)\n    return &amp;MonitoredCircuitBreaker{\n        CircuitBreaker: cb,\n        logger:        logger,\n        name:         name,\n    }\n}\n\nfunc (m *MonitoredCircuitBreaker) RecordFailure() {\n    m.CircuitBreaker.RecordFailure()\n    m.logger.Error(\"circuit breaker failure recorded\",\n        \"breaker_name\", m.name,\n        \"current_state\", \"open\",\n        \"timestamp\", time.Now())\n}\n\nfunc (m *MonitoredCircuitBreaker) RecordSuccess() {\n    m.CircuitBreaker.RecordSuccess()\n    m.logger.Info(\"circuit breaker success recorded\",\n        \"breaker_name\", m.name,\n        \"current_state\", \"closed\",\n        \"timestamp\", time.Now())\n}\n</code></pre>"},{"location":"features/logging/#best-practices","title":"Best Practices","text":""},{"location":"features/logging/#1-structured-logging","title":"1. Structured Logging","text":"<p>Always use structured logging for better searchability:</p> <pre><code>// Good - structured logging\nlogger.Error(\"database query failed\",\n    \"query\", queryString,\n    \"duration_ms\", duration.Milliseconds(),\n    \"affected_rows\", 0)\n\n// Avoid - unstructured logging\nlogger.Error(fmt.Sprintf(\"database query failed: %s (took %v)\",\n    queryString, duration))\n</code></pre>"},{"location":"features/logging/#2-consistent-log-levels","title":"2. Consistent Log Levels","text":"<p>Use appropriate log levels consistently:</p> <pre><code>// Error - for actual errors\nlogger.Error(\"failed to process payment\",\n    \"error\", err,\n    \"user_id\", userID)\n\n// Debug - for detailed troubleshooting information\nlogger.Debug(\"attempting payment processing\",\n    \"payment_provider\", provider,\n    \"amount\", amount)\n\n// Info - for tracking normal operations\nlogger.Info(\"payment processed successfully\",\n    \"transaction_id\", txID,\n    \"amount\", amount)\n</code></pre>"},{"location":"features/logging/#3-context-preservation","title":"3. Context Preservation","text":"<p>Ensure context is preserved through the logging chain:</p> <pre><code>func processWithContext(ctx context.Context) error {\n    logger := getContextLogger(ctx)\n\n    // Add request-specific context\n    requestLogger := enrichLoggerWithContext(logger, ctx)\n\n    err := performOperation()\n    if err != nil {\n        return ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithLogger(requestLogger),\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError))\n    }\n\n    return nil\n}\n\nfunc enrichLoggerWithContext(logger Logger, ctx context.Context) Logger {\n    // Extract common context values\n    requestID := ctx.Value(\"request_id\")\n    userID := ctx.Value(\"user_id\")\n\n    return &amp;ContextLogger{\n        base:      logger,\n        requestID: requestID.(string),\n        userID:    userID.(string),\n    }\n}\n</code></pre>"},{"location":"features/metadata/","title":"Error Metadata","text":"<p>Metadata is additional information attached to errors that provides crucial context for debugging and error handling. Think of metadata as tags or labels that give you deeper insight into what was happening when an error occurred. In ewrap, metadata is implemented as a flexible key-value store that travels with the error through your application.</p>"},{"location":"features/metadata/#understanding-error-metadata","title":"Understanding Error Metadata","text":"<p>When an error occurs, the error message alone often doesn't tell the complete story. For example, if a database query fails, you might want to know:</p> <ul> <li>What query was being executed?</li> <li>How long did it take before failing?</li> <li>What parameters were used?</li> <li>How many retries were attempted?</li> </ul> <p>Metadata allows you to capture all this contextual information in a structured way.</p>"},{"location":"features/metadata/#basic-metadata-usage","title":"Basic Metadata Usage","text":"<p>Let's start with the fundamentals of adding and retrieving metadata:</p> <pre><code>func processUserOrder(userID string, orderID string) error {\n    err := processOrder(orderID)\n    if err != nil {\n        return ewrap.Wrap(err, \"failed to process order\").\n            WithMetadata(\"user_id\", userID).\n            WithMetadata(\"order_id\", orderID).\n            WithMetadata(\"timestamp\", time.Now()).\n            WithMetadata(\"attempt\", 1)\n    }\n    return nil\n}\n</code></pre> <p>Retrieving metadata is just as straightforward:</p> <pre><code>func handleError(err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Get specific metadata values\n        if userID, exists := wrappedErr.GetMetadata(\"user_id\"); exists {\n            fmt.Printf(\"Error occurred for user: %v\\n\", userID)\n        }\n\n        // Log all metadata for debugging\n        if timestamp, exists := wrappedErr.GetMetadata(\"timestamp\"); exists {\n            fmt.Printf(\"Error occurred at: %v\\n\", timestamp)\n        }\n    }\n}\n</code></pre>"},{"location":"features/metadata/#structured-metadata-patterns","title":"Structured Metadata Patterns","text":"<p>While metadata values can be of any type, it's often helpful to use structured data for complex information:</p> <pre><code>type QueryMetadata struct {\n    SQL        string\n    Parameters []interface{}\n    Duration   time.Duration\n    Table      string\n}\n\nfunc executeQuery(query string, params ...interface{}) error {\n    start := time.Now()\n\n    result, err := db.Exec(query, params...)\n    if err != nil {\n        queryMeta := QueryMetadata{\n            SQL:        query,\n            Parameters: params,\n            Duration:   time.Since(start),\n            Table:      extractTableName(query),\n        }\n\n        return ewrap.Wrap(err, \"database query failed\").\n            WithMetadata(\"query_info\", queryMeta).\n            WithMetadata(\"query_attempt\", 1)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/metadata/#dynamic-metadata-collection","title":"Dynamic Metadata Collection","text":"<p>Sometimes you need to build metadata progressively as an operation proceeds:</p> <pre><code>func processComplexOperation(ctx context.Context, data []byte) error {\n    // Create error with initial metadata\n    err := ewrap.New(\"starting complex operation\",\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityInfo)).\n        WithMetadata(\"start_time\", time.Now()).\n        WithMetadata(\"data_size\", len(data))\n\n    // Process stages and collect metadata\n    stages := []string{\"validation\", \"transformation\", \"storage\"}\n    metrics := make(map[string]time.Duration)\n\n    for _, stage := range stages {\n        stageStart := time.Now()\n\n        if err := processStage(stage, data); err != nil {\n            // Add stage-specific metadata to error\n            return ewrap.Wrap(err, fmt.Sprintf(\"%s stage failed\", stage)).\n                WithMetadata(\"failed_stage\", stage).\n                WithMetadata(\"stage_metrics\", metrics).\n                WithMetadata(\"stage_duration\", time.Since(stageStart))\n        }\n\n        metrics[stage] = time.Since(stageStart)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/metadata/#metadata-for-debugging-and-monitoring","title":"Metadata for Debugging and Monitoring","text":"<p>Metadata is particularly valuable for debugging and monitoring. Here's a pattern that combines metadata with logging:</p> <pre><code>type OperationTracker struct {\n    StartTime   time.Time\n    Steps      []string\n    Metrics    map[string]interface{}\n    Attributes map[string]string\n}\n\nfunc NewOperationTracker() *OperationTracker {\n    return &amp;OperationTracker{\n        StartTime:   time.Now(),\n        Steps:      make([]string, 0),\n        Metrics:    make(map[string]interface{}),\n        Attributes: make(map[string]string),\n    }\n}\n\nfunc (ot *OperationTracker) AddStep(step string) {\n    ot.Steps = append(ot.Steps, step)\n}\n\nfunc (ot *OperationTracker) AddMetric(key string, value interface{}) {\n    ot.Metrics[key] = value\n}\n\nfunc processWithTracking(ctx context.Context, data []byte) error {\n    tracker := NewOperationTracker()\n\n    // Track operation progress\n    err := func() error {\n        tracker.AddStep(\"initialization\")\n\n        if err := validate(data); err != nil {\n            return ewrap.Wrap(err, \"validation failed\").\n                WithMetadata(\"tracker\", tracker)\n        }\n        tracker.AddStep(\"validation\")\n\n        if err := transform(data); err != nil {\n            return ewrap.Wrap(err, \"transformation failed\").\n                WithMetadata(\"tracker\", tracker)\n        }\n        tracker.AddStep(\"transformation\")\n\n        tracker.AddMetric(\"processing_time\", time.Since(tracker.StartTime))\n        return nil\n    }()\n\n    if err != nil {\n        return ewrap.Wrap(err, \"operation failed\").\n            WithMetadata(\"final_state\", tracker)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/metadata/#metadata-best-practices","title":"Metadata Best Practices","text":""},{"location":"features/metadata/#1-keep-metadata-serializable","title":"1. Keep Metadata Serializable","text":"<p>Ensure your metadata can be properly serialized when needed:</p> <pre><code>// Good - uses simple types\nerr = ewrap.New(\"processing failed\").\n    WithMetadata(\"count\", 42).\n    WithMetadata(\"status\", \"incomplete\")\n\n// Better - uses structured data that can be serialized\ntype ProcessMetadata struct {\n    Count    int    `json:\"count\"`\n    Status   string `json:\"status\"`\n    Duration string `json:\"duration\"`\n}\n\nmeta := ProcessMetadata{\n    Count:    42,\n    Status:   \"incomplete\",\n    Duration: time.Since(start).String(),\n}\n\nerr = ewrap.New(\"processing failed\").\n    WithMetadata(\"process_info\", meta)\n</code></pre>"},{"location":"features/metadata/#2-use-consistent-keys","title":"2. Use Consistent Keys","text":"<p>Maintain consistent metadata keys across your application:</p> <pre><code>// Define common metadata keys as constants\nconst (\n    MetaKeyUserID      = \"user_id\"\n    MetaKeyRequestID   = \"request_id\"\n    MetaKeyDuration    = \"duration\"\n    MetaKeyRetryCount  = \"retry_count\"\n)\n\nfunc processRequest(ctx context.Context, userID string) error {\n    requestID := ctx.Value(\"request_id\").(string)\n    start := time.Now()\n\n    err := performOperation()\n    if err != nil {\n        return ewrap.Wrap(err, \"operation failed\").\n            WithMetadata(MetaKeyUserID, userID).\n            WithMetadata(MetaKeyRequestID, requestID).\n            WithMetadata(MetaKeyDuration, time.Since(start))\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/metadata/#3-structure-complex-data","title":"3. Structure Complex Data","text":"<p>For complex metadata, use structured types:</p> <pre><code>type HTTPRequestMetadata struct {\n    Method      string\n    URL         string\n    StatusCode  int\n    Duration    time.Duration\n    Headers     map[string][]string\n}\n\nfunc makeAPICall(ctx context.Context, req *http.Request) error {\n    start := time.Now()\n    resp, err := http.DefaultClient.Do(req)\n\n    requestMeta := HTTPRequestMetadata{\n        Method:   req.Method,\n        URL:      req.URL.String(),\n        Duration: time.Since(start),\n    }\n\n    if err != nil {\n        return ewrap.Wrap(err, \"API call failed\").\n            WithMetadata(\"request_details\", requestMeta)\n    }\n\n    requestMeta.StatusCode = resp.StatusCode\n    requestMeta.Headers = resp.Header\n\n    if resp.StatusCode &gt;= 400 {\n        return ewrap.New(\"API returned error status\").\n            WithMetadata(\"request_details\", requestMeta)\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/","title":"Stack Traces","text":"<p>Stack traces are crucial for understanding where and why errors occur in your application. In ewrap, stack traces are automatically captured and enhanced to provide meaningful debugging information while maintaining performance.</p>"},{"location":"features/stack-traces/#understanding-stack-traces","title":"Understanding Stack Traces","text":"<p>A stack trace represents the sequence of function calls that led to an error. Think of it as a trail of breadcrumbs showing exactly how your program reached a particular point of failure. ewrap captures this information automatically while filtering out unnecessary noise.</p>"},{"location":"features/stack-traces/#how-ewrap-captures-stack-traces","title":"How ewrap Captures Stack Traces","text":"<p>When you create a new error using ewrap, it automatically captures the current stack trace:</p> <pre><code>func processUserData(userID string) error {\n    // This will capture the stack trace automatically\n    if err := validateUser(userID); err != nil {\n        return ewrap.New(\"user validation failed\")\n    }\n    return nil\n}\n</code></pre> <p>The captured stack trace includes:</p> <ul> <li>Function names</li> <li>File names</li> <li>Line numbers</li> <li>Package information</li> </ul> <p>However, ewrap goes beyond simple capture by:</p> <ol> <li>Filtering out runtime implementation details</li> <li>Maintaining stack traces through error wrapping</li> <li>Providing formatted output options</li> </ol>"},{"location":"features/stack-traces/#accessing-stack-traces","title":"Accessing Stack Traces","text":"<p>You can access the stack trace of an error in several ways:</p> <pre><code>func handleError(err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        // Get the full stack trace as a string\n        stackTrace := wrappedErr.Stack()\n\n        fmt.Printf(\"Error occurred: %v\\n\", err)\n        fmt.Printf(\"Stack trace:\\n%s\", stackTrace)\n    }\n}\n</code></pre> <p>When working with JSON output:</p> <pre><code>err := ewrap.New(\"database connection failed\")\njsonOutput, _ := err.ToJSON(ewrap.WithStackTrace(true))\nfmt.Println(jsonOutput)\n</code></pre>"},{"location":"features/stack-traces/#stack-trace-filtering","title":"Stack Trace Filtering","text":"<p>ewrap automatically filters stack traces to remove unhelpful information. Consider this example:</p> <pre><code>func getUserProfile(id string) (*Profile, error) {\n    profile, err := db.GetProfile(id)\n    if err != nil {\n        // The stack trace will exclude runtime internals\n        return nil, ewrap.Wrap(err, \"failed to retrieve user profile\")\n    }\n    return profile, nil\n}\n</code></pre> <p>The resulting stack trace might look like this:</p> <pre><code>/app/services/user.go:25 - getUserProfile\n/app/handlers/profile.go:42 - HandleProfileRequest\n/app/router/routes.go:156 - ServeHTTP\n</code></pre> <p>Instead of the more verbose and less helpful unfiltered version:</p> <pre><code>/app/services/user.go:25 - getUserProfile\n/app/handlers/profile.go:42 - HandleProfileRequest\n/app/router/routes.go:156 - ServeHTTP\n/usr/local/go/src/runtime/asm_amd64.s:1571 - goexit\n/usr/local/go/src/runtime/proc.go:203 - main\n...\n</code></pre>"},{"location":"features/stack-traces/#stack-traces-in-error-chains","title":"Stack Traces in Error Chains","text":"<p>When you wrap errors, ewrap preserves the original stack trace while maintaining the error chain:</p> <pre><code>func processOrder(orderID string) error {\n    // Original error with its stack trace\n    err := validateOrder(orderID)\n    if err != nil {\n        // Wraps the error while preserving the original stack trace\n        return ewrap.Wrap(err, \"order validation failed\")\n    }\n\n    err = saveOrder(orderID)\n    if err != nil {\n        // Each wrap maintains the complete error context\n        return ewrap.Wrap(err, \"failed to save order\")\n    }\n\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/#performance-considerations","title":"Performance Considerations","text":"<p>While stack traces are valuable for debugging, they do come with some overhead. ewrap optimizes this by:</p> <ol> <li>Using efficient stack capture mechanisms</li> <li>Implementing lazy formatting</li> <li>Caching stack trace strings</li> <li>Filtering irrelevant frames early</li> </ol> <p>Here's how to work with stack traces efficiently:</p> <pre><code>func processItems(items []Item) error {\n    for _, item := range items {\n        if err := processItem(item); err != nil {\n            // In tight loops, consider whether you need the stack trace\n            if isCriticalError(err) {\n                return ewrap.Wrap(err, \"critical error during item processing\")\n            }\n            // For non-critical errors, maybe just log and continue\n            log.Printf(\"Non-critical error: %v\", err)\n            continue\n        }\n    }\n    return nil\n}\n</code></pre>"},{"location":"features/stack-traces/#using-stack-traces-for-debugging","title":"Using Stack Traces for Debugging","text":"<p>Stack traces are most valuable when combined with other error context. Here's a comprehensive example:</p> <pre><code>func debugError(err error) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        fmt.Printf(\"Error Message: %v\\n\", wrappedErr.Error())\n\n        // Print the stack trace\n        fmt.Printf(\"\\nStack Trace:\\n%s\\n\", wrappedErr.Stack())\n\n        // Get any metadata\n        if metadata, ok := wrappedErr.GetMetadata(\"request_id\"); ok {\n            fmt.Printf(\"\\nRequest ID: %v\\n\", metadata)\n        }\n\n        // Print error chain\n        fmt.Println(\"\\nError Chain:\")\n        for e := wrappedErr; e != nil; e = e.Unwrap().(*ewrap.Error) {\n            fmt.Printf(\"- %s\\n\", e.Error())\n        }\n    }\n}\n</code></pre>"},{"location":"features/stack-traces/#best-practices-for-stack-traces","title":"Best Practices for Stack Traces","text":"<ol> <li> <p>Keep Stack Traces Meaningful</p> <p>In service handlers, capture enough context without excessive detail:</p> <pre><code>func (s *Service) HandleRequest(ctx context.Context, req Request) error {\n    // Capture high-level service context\n    if err := s.processRequest(ctx, req); err != nil {\n        return ewrap.Wrap(err, \"request processing failed\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError))\n    }\n    return nil\n}\n</code></pre> </li> <li> <p>Combine with Logging</p> <p>Integrate stack traces with your logging system:</p> <pre><code>func logError(err error, logger Logger) {\n    if wrappedErr, ok := err.(*ewrap.Error); ok {\n        logger.Error(\"operation failed\",\n            \"error\", wrappedErr.Error(),\n            \"stack\", wrappedErr.Stack(),\n            \"type\", ewrap.GetErrorType(wrappedErr))\n    }\n}\n</code></pre> </li> <li> <p>Use in Development and Testing</p> <p>Stack traces are particularly valuable during development and testing:</p> <pre><code>func TestComplexOperation(t *testing.T) {\n    err := performComplexOperation()\n    if err != nil {\n        t.Errorf(\"Operation failed with stack trace:\\n%+v\", err)\n    }\n}\n</code></pre> </li> </ol>"},{"location":"features/stack-traces/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":"<ol> <li> <p>Stack Trace Depth</p> <p>If you're seeing too much or too little information:</p> <pre><code>// Too much information\nerr := ewrap.New(\"operation failed\")\n\n// Just right - wrap with context\nerr := ewrap.New(\"operation failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityError)).\n    WithMetadata(\"operation\", \"user_update\")\n</code></pre> </li> <li> <p>Missing Context</p> </li> </ol> <p>Ensure you're capturing relevant context with your stack traces:</p> <pre><code>func handleRequest(ctx context.Context, req *Request) error {\n    if err := validateRequest(req); err != nil {\n        // Include request context with the stack trace\n        return ewrap.Wrap(err, \"invalid request\",\n            ewrap.WithContext(ctx, ewrap.ErrorTypeValidation, ewrap.SeverityError)).\n            WithMetadata(\"request_id\", req.ID).\n            WithMetadata(\"user_id\", req.UserID)\n    }\n    return nil\n}\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<pre><code>go get github.com/hyp3rd/ewrap\n</code></pre>"},{"location":"getting-started/installation/#usage-examples","title":"Usage Examples","text":""},{"location":"getting-started/installation/#basic-error-handling","title":"Basic Error Handling","text":"<p>Create and wrap errors with context:</p> <pre><code>import \"github.com/hyp3rd/ewrap\"\n// ...\n// Create a new error\nerr := ewrap.New(\"database connection failed\")\n\n// Wrap an existing error with context\nif err != nil {\n    return ewrap.Wrap(err, \"failed to process request\")\n}\n</code></pre>"},{"location":"getting-started/installation/#advanced-error-context","title":"Advanced Error Context","text":"<p>Add rich context and metadata to errors:</p> <pre><code>import \"github.com/hyp3rd/ewrap\"\n// ...\nerr := ewrap.New(\"operation failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger)).\n    WithMetadata(\"query\", \"SELECT * FROM users\").\n    WithMetadata(\"retry_count\", 3)\n\n// Log the error with all context\nerr.Log()\n</code></pre>"},{"location":"getting-started/installation/#error-groups-with-pooling","title":"Error Groups with Pooling","text":"<p>Use error groups efficiently in high-throughput scenarios:</p> <pre><code>// Create an error group pool with initial capacity\npool := ewrap.NewErrorGroupPool(4)\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Return to pool when done\n\n// Add errors as needed\neg.Add(err1)\neg.Add(err2)\n\nif eg.HasErrors() {\n    return eg.Error()\n}\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with ewrap quickly. We'll cover the basic concepts and show you how to use the main features of the package.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#creating-errors","title":"Creating Errors","text":"<p>The simplest way to create an error with ewrap is using the <code>New</code> function:</p> <pre><code>err := ewrap.New(\"something went wrong\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-context","title":"Adding Context","text":"<p>You can add context to your errors using various options:</p> <pre><code>err := ewrap.New(\"database connection failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger))\n</code></pre>"},{"location":"getting-started/quickstart/#wrapping-errors","title":"Wrapping Errors","text":"<p>When you want to add context to an existing error:</p> <pre><code>if err != nil {\n    return ewrap.Wrap(err, \"failed to process request\")\n}\n</code></pre>"},{"location":"getting-started/quickstart/#using-error-groups","title":"Using Error Groups","text":"<p>Error groups help you collect and manage multiple errors:</p> <pre><code>// Create an error group pool\npool := ewrap.NewErrorGroupPool(4)\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Don't forget to release it back to the pool\n\n// Add errors as needed\neg.Add(err1)\neg.Add(err2)\n\nif eg.HasErrors() {\n    return eg.Error()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#implementing-circuit-breaker","title":"Implementing Circuit Breaker","text":"<p>Protect your system from cascading failures:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\nif cb.CanExecute() {\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()\n        return err\n    }\n    cb.RecordSuccess()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ol> <li>Learn about Error Types</li> <li>Explore Logging Integration</li> <li>Study Advanced Usage</li> <li>Check out complete Examples</li> </ol>"},{"location":"getting-started/quickstart/#best-practices","title":"Best Practices","text":"<p>Here are some best practices to follow when using ewrap:</p> <ol> <li>Always provide meaningful error messages</li> <li>Use appropriate error types and severity levels</li> <li>Release error groups back to their pools</li> <li>Configure circuit breakers based on your system's characteristics</li> <li>Implement proper logging integration</li> <li>Use metadata to add relevant debugging information</li> </ol>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you might find useful:</p> <pre><code>func processItem(ctx context.Context, item string) error {\n    // Create error group from pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate input\n    if err := validate(item); err != nil {\n        eg.Add(ewrap.Wrap(err, \"validation failed\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Process if no validation errors\n    if !eg.HasErrors() {\n        if err := process(item); err != nil {\n            return ewrap.Wrap(err, \"processing failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeInternal))\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre> <p>This is just a starting point. For more detailed information about specific features, check out the relevant sections in the documentation.</p>"}]}