{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ewrap Documentation","text":"<p>Welcome to the documentation for <code>ewrap</code>, a sophisticated error handling package for Go applications that provides comprehensive error management capabilities with a focus on performance and developer experience.</p>"},{"location":"#overview","title":"Overview","text":"<p>ewrap is designed to make error handling in Go applications more robust, informative, and maintainable. It provides a rich set of features while maintaining excellent performance characteristics through careful optimization and efficient memory management.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Stack Traces: Automatically capture and filter stack traces for meaningful error debugging</li> <li>Error Wrapping: Maintain error chains while preserving context</li> <li>Metadata Attachment: Attach and manage arbitrary key-value pairs to errors</li> <li>Logging Integration: Flexible logger interface supporting major logging frameworks</li> <li>Error Categorization: Built-in error types and severity levels</li> <li>Circuit Breaker Pattern: Protect your systems from cascading failures</li> <li>Efficient Error Grouping: Pool-based error group management</li> <li>Context Preservation: Rich error context preservation</li> <li>Thread-Safe Operations: Safe for concurrent use</li> <li>Format Options: JSON and YAML output support</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a quick example of how ewrap can be used in your application:</p> <pre><code>func processOrder(ctx context.Context, orderID string) error {\n    // Get an error group from the pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Create a circuit breaker\n    cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\n    // Add validation errors to the group\n    if err := validateOrder(orderID); err != nil {\n        eg.Add(ewrap.Wrap(err, \"invalid order\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation),\n            ewrap.WithLogger(logger)))\n    }\n\n    // Handle database operations with circuit breaker\n    if !eg.HasErrors() &amp;&amp; cb.CanExecute() {\n        if err := saveToDatabase(orderID); err != nil {\n            cb.RecordFailure()\n            return ewrap.Wrap(err, \"database operation failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n                ewrap.WithRetry(3, time.Second*5))\n        }\n        cb.RecordSuccess()\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To start using ewrap in your project, visit the Installation guide, followed by the Quick Start tutorial.</p>"},{"location":"#why-ewrap","title":"Why ewrap?","text":"<p>ewrap was created to address common challenges in error handling:</p> <ol> <li>Lack of Context: Traditional error handling often loses important context</li> <li>Performance Overhead: Many error handling libraries introduce significant overhead</li> <li>Memory Management: Poor memory management in error handling can lead to increased GC pressure</li> <li>Inconsistent Logging: Different parts of an application often handle error logging differently</li> <li>Missing Stack Traces: Getting meaningful stack traces can be challenging</li> <li>Circuit Breaking: Protecting systems from cascading failures requires complex implementation</li> </ol> <p>ewrap solves these challenges while maintaining excellent performance characteristics and providing a clean, intuitive API.</p>"},{"location":"advanced/error-strategies/","title":"Error Handling Strategies","text":"<p>Understanding how to effectively handle errors is crucial for building robust applications. This guide explores various error handling strategies using ewrap and explains when to use each approach.</p>"},{"location":"advanced/error-strategies/#understanding-error-context","title":"Understanding Error Context","text":"<p>Error context is more than just an error message - it's the complete picture of what happened when an error occurred. With ewrap, you can capture rich context that helps with debugging and error resolution.</p>"},{"location":"advanced/error-strategies/#basic-context","title":"Basic Context","text":"<p>At its simplest, context includes:</p> <pre><code>err := ewrap.New(\"user not found\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeNotFound, ewrap.SeverityError))\n</code></pre> <p>This tells us:</p> <ul> <li>What happened (\"user not found\")</li> <li>The type of error (NotFound)</li> <li>How severe the error is (Error level)</li> </ul>"},{"location":"advanced/error-strategies/#enhanced-context","title":"Enhanced Context","text":"<p>For more complex scenarios, you can add detailed context:</p> <pre><code>err := ewrap.New(\"database query failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger)).\n    WithMetadata(\"query\", query).\n    WithMetadata(\"table\", \"users\").\n    WithMetadata(\"affected_rows\", 0).\n    WithMetadata(\"latency_ms\", queryTime.Milliseconds())\n</code></pre> <p>This provides a complete picture:</p> <ul> <li>The operation that failed</li> <li>Where it failed</li> <li>Related technical details</li> <li>Performance metrics</li> </ul>"},{"location":"advanced/error-strategies/#error-group-strategies","title":"Error Group Strategies","text":"<p>Error groups are powerful tools for handling multiple potential errors in a single operation. Here's how to use them effectively:</p>"},{"location":"advanced/error-strategies/#validation-scenarios","title":"Validation Scenarios","text":"<p>When validating multiple fields or conditions:</p> <pre><code>func validateUser(user User) error {\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate email\n    if !isValidEmail(user.Email) {\n        eg.Add(ewrap.New(\"invalid email format\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate age\n    if user.Age &lt; 18 {\n        eg.Add(ewrap.New(\"user must be 18 or older\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Validate username\n    if len(user.Username) &lt; 3 {\n        eg.Add(ewrap.New(\"username too short\",\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#parallel-operations","title":"Parallel Operations","text":"<p>When handling concurrent operations:</p> <pre><code>func processItems(ctx context.Context, items []Item) error {\n    pool := ewrap.NewErrorGroupPool(len(items))\n    eg := pool.Get()\n    defer eg.Release()\n\n    var wg sync.WaitGroup\n    for _, item := range items {\n        wg.Add(1)\n        go func(item Item) {\n            defer wg.Done()\n            if err := processItem(ctx, item); err != nil {\n                eg.Add(ewrap.Wrap(err, fmt.Sprintf(\"failed to process item %d\", item.ID)))\n            }\n        }(item)\n    }\n\n    wg.Wait()\n    return eg.Error()\n}\n</code></pre>"},{"location":"advanced/error-strategies/#circuit-breaker-patterns","title":"Circuit Breaker Patterns","text":"<p>Circuit breakers help prevent system overload by failing fast when problems are detected. Here are some patterns for using them effectively:</p>"},{"location":"advanced/error-strategies/#basic-circuit-breaker","title":"Basic Circuit Breaker","text":"<p>For simple protection:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 5, time.Minute)\n\nfunc queryDatabase() error {\n    if !cb.CanExecute() {\n        return ewrap.New(\"circuit breaker open\",\n            ewrap.WithErrorType(ewrap.ErrorTypeDatabase),\n            ewrap.WithMetadata(\"breaker\", \"database\"))\n    }\n\n    if err := performQuery(); err != nil {\n        cb.RecordFailure()\n        return err\n    }\n\n    cb.RecordSuccess()\n    return nil\n}\n</code></pre>"},{"location":"advanced/error-strategies/#cascading-circuit-breakers","title":"Cascading Circuit Breakers","text":"<p>For systems with dependencies:</p> <pre><code>type Service struct {\n    dbBreaker    *ewrap.CircuitBreaker\n    cacheBreaker *ewrap.CircuitBreaker\n    apiBreaker   *ewrap.CircuitBreaker\n}\n\nfunc (s *Service) getData(ctx context.Context, id string) (Data, error) {\n    // Try cache first\n    if s.cacheBreaker.CanExecute() {\n        data, err := queryCache(id)\n        if err == nil {\n            s.cacheBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.cacheBreaker.RecordFailure()\n    }\n\n    // Fall back to database\n    if s.dbBreaker.CanExecute() {\n        data, err := queryDatabase(id)\n        if err == nil {\n            s.dbBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.dbBreaker.RecordFailure()\n    }\n\n    // Last resort: external API\n    if s.apiBreaker.CanExecute() {\n        data, err := queryAPI(id)\n        if err == nil {\n            s.apiBreaker.RecordSuccess()\n            return data, nil\n        }\n        s.apiBreaker.RecordFailure()\n    }\n\n    return Data{}, ewrap.New(\"all data sources failed\",\n        ewrap.WithErrorType(ewrap.ErrorTypeInternal),\n        ewrap.WithContext(ctx, ewrap.ErrorTypeInternal, ewrap.SeverityCritical))\n}\n</code></pre>"},{"location":"advanced/error-strategies/#best-practices-for-error-recovery","title":"Best Practices for Error Recovery","text":"<p>When handling errors, consider implementing recovery strategies:</p> <ol> <li> <p>Graceful Degradation:</p> <pre><code>func getProductDetails(ctx context.Context, id string) (Product, error) {\n    var product Product\n\n    // Get core product data\n    data, err := getProductData(id)\n    if err != nil {\n        // Log the error but continue with partial data\n        logger.Error(\"failed to get full product data\", \"error\", err)\n        product.Status = \"partial\"\n    } else {\n        product.Status = \"complete\"\n    }\n\n    // Get non-critical enrichment data\n    reviews, err := getProductReviews(id)\n    if err != nil {\n        // Add metadata about missing data\n        err = ewrap.Wrap(err, \"failed to get reviews\",\n            ewrap.WithMetadata(\"missing_component\", \"reviews\"),\n            ewrap.WithErrorType(ewrap.ErrorTypePartial))\n        logger.Warn(\"serving product without reviews\", \"error\", err)\n    }\n\n    return product, nil\n}\n</code></pre> </li> <li> <p>Retry Patterns:</p> </li> </ol> <pre><code>func withRetry(operation func() error, maxAttempts int, delay time.Duration) error {\n    var lastErr error\n\n    for attempt := 1; attempt &lt;= maxAttempts; attempt++ {\n        err := operation()\n        if err == nil {\n            return nil\n        }\n\n        lastErr = ewrap.Wrap(err, \"operation failed\",\n            ewrap.WithMetadata(\"attempt\", attempt),\n            ewrap.WithMetadata(\"max_attempts\", maxAttempts))\n\n        if attempt &lt; maxAttempts {\n            time.Sleep(delay * time.Duration(attempt))\n        }\n    }\n\n    return lastErr\n}\n</code></pre> <p>The key to effective error handling is choosing the right strategy for each situation. Consider:</p> <ul> <li>The criticality of the operation</li> <li>Performance requirements</li> <li>User experience implications</li> <li>System resources</li> <li>Dependencies and their reliability</li> </ul> <p>By understanding these factors and using ewrap's features appropriately, you can build robust and maintainable error handling systems.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will help you get started with ewrap quickly. We'll cover the basic concepts and show you how to use the main features of the package.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/quickstart/#creating-errors","title":"Creating Errors","text":"<p>The simplest way to create an error with ewrap is using the <code>New</code> function:</p> <pre><code>err := ewrap.New(\"something went wrong\")\n</code></pre>"},{"location":"getting-started/quickstart/#adding-context","title":"Adding Context","text":"<p>You can add context to your errors using various options:</p> <pre><code>err := ewrap.New(\"database connection failed\",\n    ewrap.WithContext(ctx, ewrap.ErrorTypeDatabase, ewrap.SeverityCritical),\n    ewrap.WithLogger(logger))\n</code></pre>"},{"location":"getting-started/quickstart/#wrapping-errors","title":"Wrapping Errors","text":"<p>When you want to add context to an existing error:</p> <pre><code>if err != nil {\n    return ewrap.Wrap(err, \"failed to process request\")\n}\n</code></pre>"},{"location":"getting-started/quickstart/#using-error-groups","title":"Using Error Groups","text":"<p>Error groups help you collect and manage multiple errors:</p> <pre><code>// Create an error group pool\npool := ewrap.NewErrorGroupPool(4)\n\n// Get an error group from the pool\neg := pool.Get()\ndefer eg.Release()  // Don't forget to release it back to the pool\n\n// Add errors as needed\neg.Add(err1)\neg.Add(err2)\n\nif eg.HasErrors() {\n    return eg.Error()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#implementing-circuit-breaker","title":"Implementing Circuit Breaker","text":"<p>Protect your system from cascading failures:</p> <pre><code>cb := ewrap.NewCircuitBreaker(\"database\", 3, time.Minute)\n\nif cb.CanExecute() {\n    err := performOperation()\n    if err != nil {\n        cb.RecordFailure()\n        return err\n    }\n    cb.RecordSuccess()\n}\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, you can:</p> <ol> <li>Learn about Error Types</li> <li>Explore Logging Integration</li> <li>Study Advanced Usage</li> <li>Check out complete Examples</li> </ol>"},{"location":"getting-started/quickstart/#best-practices","title":"Best Practices","text":"<p>Here are some best practices to follow when using ewrap:</p> <ol> <li>Always provide meaningful error messages</li> <li>Use appropriate error types and severity levels</li> <li>Release error groups back to their pools</li> <li>Configure circuit breakers based on your system's characteristics</li> <li>Implement proper logging integration</li> <li>Use metadata to add relevant debugging information</li> </ol>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":"<p>Here are some common patterns you might find useful:</p> <pre><code>func processItem(ctx context.Context, item string) error {\n    // Create error group from pool\n    pool := ewrap.NewErrorGroupPool(4)\n    eg := pool.Get()\n    defer eg.Release()\n\n    // Validate input\n    if err := validate(item); err != nil {\n        eg.Add(ewrap.Wrap(err, \"validation failed\",\n            ewrap.WithContext(ctx),\n            ewrap.WithErrorType(ewrap.ErrorTypeValidation)))\n    }\n\n    // Process if no validation errors\n    if !eg.HasErrors() {\n        if err := process(item); err != nil {\n            return ewrap.Wrap(err, \"processing failed\",\n                ewrap.WithContext(ctx),\n                ewrap.WithErrorType(ewrap.ErrorTypeInternal))\n        }\n    }\n\n    return eg.Error()\n}\n</code></pre> <p>This is just a starting point. For more detailed information about specific features, check out the relevant sections in the documentation.</p>"}]}